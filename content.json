{"pages":[{"title":"About","text":"作为一个顶天立地的人，你要无怨无悔地走完自己的人生历程。想要怎样才能充实地走完这段历程，这是一个值得思考的问题。是碌碌无为，虚度韶华？还是踏踏实实，拼搏奋斗？这取决于自己。要想成就理想，需要做到不唯众，不唯上。不在意普通的路上是否比别人走得更快，而是又在无人行走的荒野上行走的勇气，这样才能看到别人无法看到的情境。 关于我一枚程序员，这是我对自己现阶段的描述。 虽然文笔一般，但是我还是想写点东西记录些什么，包括学习过程中的一些感悟。 至于写博客，也不算是一时间的心血来潮，很久之前就有过这样的想法，也尝试过很多种方式，最终以现在这种方式呈现出来。 持续更新中… 读书目录 SpringBoot 编程思想 Effective Java Java编程思想 Java8实战 Spring Cloud微服务实战","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"行为参数化","text":"本篇内容摘自《Java8 实战》 前言行为参数化和“策略设计模式”相关，它让你定义算法，并将其封装起来（这里称为“策略”），在运行的时候选择一个算法，如果你现在不太明白这句话的意思，可以紧张兮兮的往下看，我将会通过一系列的例子来展示什么叫做行为参数化，以及这种设计模式的优点。 需求0、准备我们先准备一个苹果的实体类，重写它的toString()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Apple { /** * 苹果颜色 */ private String color; /** * 苹果重量（单位：克） */ private Integer weight; public Apple(String color, Integer weight) { this.color = color; this.weight = weight; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Integer getWeight() { return weight; } public void setWeight(Integer weight) { this.weight = weight; } @Override public String toString() { return \"Apple{\" + \"color='\" + color + '\\'' + \", weight=\" + weight + '}'; }} 然后准备一个工具类去生成测试代码所需的苹果的集合 1234567891011121314151617public class AppleUtil { public static List&lt;Apple&gt; getApples() { return Arrays.asList( new Apple(\"green\", 100), new Apple(\"green\", 120), new Apple(\"red\", 130), new Apple(\"green\", 140), new Apple(\"red\", 150), new Apple(\"green\", 160), new Apple(\"green\", 170), new Apple(\"red\", 180), new Apple(\"green\", 190), new Apple(\"red\", 200), new Apple(\"green\", 210) ); }} 至此，准备工作完成。 1、筛选绿苹果首先，我们需要从一堆苹果中筛选出绿色的苹果 12345678910111213141516171819202122public class Demo1 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterGreenApples(AppleUtil.getApples()); for (Apple apple : apples) { System.out.println(apple); } } /** * 获取绿色的苹果 * @param inventory 未筛选的苹果集合 * @return 绿色苹果的集合 */ public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"green\".equals(apple.getColor())) { result.add(apple); } } return result; }} 这很简单，我们定义了一个filterGreenApples方法，参数为List&lt;Apple&gt;，然后在方法体内遍历这个List，如果苹果是绿色的，就把这个苹果放到新的List&lt;Apple&gt;中，遍历完成后返回新的List&lt;Apple&gt;。 2、筛选红苹果有了筛选绿苹果的经历 ，我们微微一笑，将之前封装的filterGreenApples复制一份，然后改名为filterRedApples,然后修改if代码块中的代码修改为&quot;red&quot;.equals(apple.getColor()),其完整代码如下 123456789public static List&lt;Apple&gt; filterRedApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"red\".equals(apple.getColor())) { result.add(apple); } } return result; } 看上去我们“完美”的完成了任务，准备提交代码的时候，又来了一个需求，筛选一半红一半绿的苹果，这时候我们就不太想复制之前的代码了，何不将颜色作为参数传入方法中呢，说干就干 123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, String color) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (color.equals(apple.getColor())) { result.add(apple); } } return result; } 但是这里又暴露出其他问题了，比如，我要筛选出出重量大于150g的苹果，我要筛选出出重量大于150g的红苹果，那我们现有的架构也没法实现这个需求，而且封装的方法会越来越庞大，我们下面将介绍如何去解决这些我呢提。 3、代码重构首先我们写一个接口ApplePredicate 12345@FunctionalInterfacepublic interface ApplePredicate { boolean test(Apple apple);} 我们先不管这个注解，然后再写两个实现类，AppleGreenColorPredicate，AppleHeavyWeightPredicate 123456public class AppleGreenColorPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); }} 123456public class AppleHeavyWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() &gt; 150; }} 然后我们可以封装这样一个方法 123456789public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; } 测试代码 1234567public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } 具体的代码逻辑直接在ApplePredicate的实现类中实现就可以了，将具体的行为当作参数传入到方法中，这就是行为参数化。","link":"/2018/08/11/behavioral-parameterization/"},{"title":"自定义注解实战（一）","text":"利用AOP实现注解个人见解：使用aop最大的好处是不侵入业务代码，就可以在方法执行前或者执行后来实现某些功能，比如日志打印，权限处理等等。正是因为不侵入代码的特性，我们不建议利用aop去截断请求（request），返回包含错误信息的响应（response）。其实我之前有这么做过，自定义权限注解，用户没有权限的话，直接返回没有权限的错误信息（response），功能上可以实现，虽然给我抛异常了，有代码洁癖的我就只能使用拦截器的方法实现该注解了，利用拦截器实现注解将在 自定义注解实战（二） 中来介绍，本篇介绍利用aop来实现注解——当说明书来看吧。。。 自定义注解我们先定义一个MyAnno的注解，代码如下： 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface MyAnno { String value();} 其中，@Target(ElementType.METHOD) 定义该注解作用在方法上，使用value()我们在写注解@MyAnno的时候可以直接@MyAnno(&quot;msg&quot;),如果你按照下面的代码来定义注解的话， 123public @interface MyAnno { String param();} 那你使用注解的时候就只能@MyAnno(param = &quot;msg&quot;)了，不管是@MyAnno(&quot;msg&quot;)，还是@MyAnno(param = &quot;msg&quot;)，括号里面都要写value的，如果你定义的注解不需要写的话，那么就在定义的时候加上 default &quot;&quot;;，如下： 123public @interface MyAnno { String param() defaul \"\";} 实现注解按照上面定义完注解其实已经可以使用了，但是没什么功能，如果想让我们自定义的注解work起来，需要利用到Aspectj： 12345678910111213141516171819202122@Aspect@Componentpublic class RealizationMyAnno { @Pointcut(\"@annotation(com.bfh.annotation.MyAnno)\") public void MyMethod(){} @After(\"MyMethod()\") public void doAfterReturning(JoinPoint joinPoint){ System.out.println(\"RealizationMyAnno.doAfterReturning()\"); String targetName = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] params = joinPoint.getArgs(); // 实际开发过程中使用log打印 System.out.println(\"targetName:\" + targetName); System.out.println(\"methodName:\" + methodName); }} 这时候我们可以将我们自定义的注解加在方法上了，当程序执行到该方法时，就会打印一些信息，如果targetName，methodName，你也可以做些其他的事情，比如自动打印日志，自动将日志输出到硬盘上等等。。。 补充：其实利用aop去截断request请求也是可以的（如果必须的话），利用异常来截断请求，然后设置统一异常处理，向前端返回错误信息，不过不推荐用异常来处理业务。。。","link":"/2018/04/05/annotation-in-action-01/"},{"title":"自定义注解实战（二）","text":"利用拦截器实现注解上一篇 自定义注解实战（一） 中说到使用aop最大的好处是不侵入业务代码，但是有些业务需要拦截请求，比如参数校验，为空的话直接返回isNull的错误信息，这时候用AOP来做这件事就显得不太优雅了，所以我想到了用拦截器来实现，定义注解的方式还是一样，这里就不多加赘述了。 声明拦截器声明拦截器我们利用SpringMVC进行配置，而在mvc:interceptors标签下声明interceptor主要有两种方式： 直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。 因为利用拦截器去实现注解的话，要拦截所有请求，所以这里我们直接使用第一种方法，直接定义一个Interceptor实现类的bean对象： 123&lt;mvc:interceptors&gt; &lt;bean class=\"com.bfh.interceptor.MyAnnoInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 实现注解然后就是实现MyAnnoInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyAnnoInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.setHeader(\"Content-type\", \"application/json;charset=utf-8\"); try { if (handler instanceof HandlerMethod) { HandlerMethod method = (HandlerMethod) handler; MyAnno annotationParams = method.getMethodAnnotation(MyAnno.class); /** * 你定义的校验规则,如果通过校验，直接return true; */ } PrintWriter out = null; try { out = response.getWriter(); out.print(\"你想输出的错误信息...\"); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { if (out != null) { out.close(); } } return false; } catch (Exception e) { e.printStackTrace(); } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, org.springframework.web.servlet.ModelAndView arg3) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response,Object arg2, Exception arg3) throws Exception { }} 这样我们自定义的注解就可以使用了，至于return true还是return false，这个就看你的实际业务需求了。","link":"/2018/04/06/annotation-in-action-02/"},{"title":"Docker(一)：hello-docker","text":"docker概述Docker是一个开发，运输和运行应用程序的开放平台。Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。 准备工作之前就打算在虚拟机安装centos来好好熟悉下linux，不过事情比较多，一直都没有去做。这次刚好打算了解一波docker，所以就把之前丢掉的linux捡起来。 首先我们准备一个centos环境，这里我安装的是CentOS-7-x86_64-Everything-1804，安装好后打算用终端模拟软件去连接，方便操作。在记忆中搜索片刻，敲下了ifconfig，不过好像我安装的这个版本没有给我安装ifconfig等命令，百度一看说是过时了，那找解决办法吧，ip addr，但是没看见熟悉的xxx.xxx.xxx.xxx，额，又去百度一看，需要我们配置网卡。 那就配置吧，按照百度来的教程，vi /etc/sysconfig/network-scripts/ifcfg-xxx，其实这个命令最后的xxx，就是我们敲ip addr后显示的2：后面的数值，1：一般是lo：，打开后将最后一个ONBOOT=no修改为ONBOOT=yes，这样便能启动网卡，然后我们重启网络服务service network restart，再敲ip addr就能看见IP地址了。 docker安装首先 运行命令yum install docker安装docker，然后我们通过docekr version来查看docker是否安装成功 12345[root@localhost ~]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: 这里能看到我们安装的版本是1.13.1。然后我们启动docker服务，将其设置为 开机启动 12service docker startchkconfig docker on 修改docker镜像仓库就像使用maven要修改镜像仓库那样，使用docker也不例外，我们可以将其修改为docker中国官方提供的registry.docker-cn.com来访问，其中包含了主流的docker镜像，通过修改/etc/docker/daemon.json文件，添加如下配置，如果是第一次安装docker，该文件中只是{}，替换如下内容即可。 1234{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;live-restore&quot;: true} hello world像我们学习编程语言的时候，第一个例子便是输出一行hello world，不过docker提供有docker版的hello world 供我们下载使用，我们通过docker pull去获取它。 123456Using default tag: latestTrying to pull repository docker.io/library/hello-world ... latest: Pulling from docker.io/library/hello-world9db2ca6ccae0: Pull complete Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for docker.io/hello-world:latest 我们可以通过docker image ls去查看我们本地安装有哪些镜像 12REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/hello-world latest 2cb0d9787c4d 6 weeks ago 1.85 kB 证明镜像下载到本地后，我们通过docker run hello-world 来运行这个镜像 1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 输出这段提示后，hello-world便自动终止了（像mysql，redis这些提供服务的镜像是不会自动终止）。 docker常用命令123456# 启动service docker start# 重启service docker restar# 停止service docker stop 参考 docker docs Docker(一)：Docker入门教程 周立–Docker系列教程","link":"/2018/09/02/docker-in-action-01/"},{"title":"构建Spring Boot Starter(一)","text":"Spring Boot Starter初印象初识Spring Boot 时，被其简化Spring应用初始搭建以及开发过程所惊艳到，基于约定优于配置的原则，我们无需从老项目中拷贝大量的xml文件来构建项目，只需利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 就能轻松启动一个Spring应用，极为便捷。 除此之外，以前在没有使用Spring Boot的时候，引入第三方jar包——如引入Mybatis的时候，我们需要在pom文件中引入多个依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;&lt;/dependency&gt; 这无疑给我们做第三方集成的时候增加了难度，也相应增加了依赖管理的难度，如果使用Spring Boot，我们只需引入一个依赖就ok： 1234&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 这是因为 mybatis-spring-boot-starter 其本身可以理解为一个库的集合，帮我们管理了spring整合mybatis所需的依赖。 Spring Boot Starter帮我们处理了Spring应用中各种库之间复杂的依赖关系，但是这不是本篇博客介绍的重点。我们这里计划实现一个自动配置的 starter ，类似启用Eureka的自动注册功能，只需在工程启动类上面加上 @EnableEurekaClient 便可开启服务注册发现功能（需要引入相关依赖），极为方便。 准备工作首先我们要了解Spring官方推荐的命名规范，其中官方starter命名： spring-boot-starter-[name] ，非官方命名： [name]-spring-boot-starter ，所以这里我们给工具starter命名为 build-spring-boot-starter 。 然后我们利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 构建一个spring boot项目，然后引入开发Spring Boot Starter核心依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt; 然后我们准备两个Serivice 用于自动配置，写的简单些，一个将字符串转为大写，一个求两个int型的最大值，都是用了现成的方法，如下： IntegerService： 12345678910public class IntegerService { /** * 取两个int的最大值 */ public int max(int i1, int i2) { return Integer.max(i1, i2); }} StringService: 1234567891011121314public class StringService { /** * 将字符串转为大写 */ public String toUpperCase(String str) { if (StringUtils.isEmpty(str)) { return null; } else { return str.toUpperCase(); } }} 然后准备两个配置类： 123456public class IntegerServiceConfig { @Bean IntegerService integerService() { return new IntegerService(); }} 123456public class StringServiceConfig { @Bean StringService stringService() { return new StringService(); }} 然后让其自动配置，这里提供两种方式： 在resources/META-INF/下创建spring.factories文件，配置如下： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.github.baifenghe.configuration.IntegerServiceConfig 因为Spring Boot在启动的时候会扫描项目所依赖的JAR包，寻找其中spring.factories文件，然后根据其配置来加载配置类。 上述方法只要工程依赖该 starter 后便自动注入所有配置过的Bean，但是我们有时候并不想这样，可能有时候我们只需要使用一个功能，但是却将 starter 里面不需要的Bean也都注入进来，所以我们想通过一个注解来自定义开启某些功能，而不是全部开启，这时候我们可以利用 @Import 注解来实现上诉功能： 首先我们创建一个注解，EnableStringService 123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({StringServiceConfig.class})public @interface EnableStringService {} 用 @Import 来发现配置类从而注入，很类似之前将多个配置文件导入一个主配置文件中一样。 接下来我们来测试刚刚写好的starter ，首先利用 mvn install 将刚刚开发好的 starter 安装到本地，然后新建一个 spring boot 工程引入本依赖， 1234567891011&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.baifenghe&lt;/groupId&gt; &lt;artifactId&gt;build-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后我们写一个Controller来测试我们写的starter，如下： 12345678910111213141516171819202122232425262728@RestControllerpublic class DemoController { @Autowired private IntegerService integerService; @Autowired private StringService stringService; /** * 测试StringService */ @PostMapping(\"testStringService\") public String testStringService(String str) { return stringService.toUpperCase(str); } /** * 测试IntegerService */ @PostMapping(\"testIntegerService\") public int testIntegerService(int n1, int n2) { return integerService.max(n1, n2); }} 在主类上引用 @EnableStringService 注解，开启 StringService（IntegerService 自动注入了） 。 相关代码详见：build-spring-boot 最后的最后，欢迎 watch star fork toolkit-spring-boot-project ，一个好用的，开箱即用的工具集。","link":"/2019/01/08/build-spring-boot-starter-01/"},{"title":"Docker(二)：部署springboot项目","text":"Dockerfile概述Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Docker可以通过读取来自 Dockerfile的指令自动构建镜像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用、组合容器的所有命令。使用docker build 可以构建连续执行的多个指令集。 接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以docker部署springboot项目为例。 准备springboot项目首先我们通过spring initializr来构建一个springboot工程，只添加了一个HelloController，代码如下： 1234567@RestControllerpublic class HelloDockerController { @RequestMapping(\"/hello\") public String hello() { return \"hello, \" + LocalDateTime.now(); }} 可以使用docker构建插件来构建镜像，可以查考纯洁的微笑的博客来构建，这里我们直接将springboot工程打成jar包，来构建docker镜像。 首先将之前构建的springboot工程打包，这样我们就得到了一个hello-docker-0.0.1-SNAPSHOT.jar,然后我们再准备一个Dockerfile，内容如下 1234FROM java:8VOLUME /tmpADD hello-docker-0.0.1-SNAPSHOT.jar hello-docker.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/hello-docker.jar&quot;] 其中 FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 构建镜像 1docker build -t image-name . 然后我们通过docker images就能看见我们制作的docker镜像 12345REPOSITORY TAG IMAGE ID CREATED SIZEhello-docker latest 417dca81c225 8 minutes ago 672 MBdocker.io/mysql 5.7 563a026a1511 2 weeks ago 372 MBdocker.io/nginx latest c82521676580 2 months ago 109 MBdocker.io/java 8 d23bdf5b1b1b 20 months ago 643 MB 这样我们可以启动该镜像 1docker run -p 8080:8080 -t hello-docker 如果出现了端口映射错误，可以暂时关闭防火墙systemctl stop firewalld.service，然后重启docker服务service docker restart，重新启动镜像即可。 通过docker ps可以查看正在运行的项目 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScaa44939f959 hello-docker &quot;java -Djava.secur...&quot; 14 seconds ago Up 13 seconds 0.0.0.0:8080-&gt;8080/tcp trusting_brattainf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 7 days ago Up 2 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 然后通过访问http://your-ip:8080/hello，返回 1hello, 2018-09-25T13:38:53.246 即部署成功。 参考 docker docs Docker(二)：Dockerfile 使用介绍","link":"/2018/09/26/docker-in-action-02/"},{"title":"Docker(三)：使用docker启动mysql & redis","text":"docker很便捷，最开始有这种感受是用一行命令去启动了mysql服务。想当初刚接触数据库那会，那么费力气的安装mysql也是服气。（捂脸哭~ 但是在启动mysql容器之前，我们需要做些准备工作，这是因为数据库本身的特殊性，我们需要将容器的数据映射到主机的目录中，这样就不担心手滑将容器删除导致数据丢失了。 准备工作首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 1234mkdir /opt/dockermkdir /opt/docker/mysqlmkdir /opt/docker/mysql/confmkdir /opt/docker/mysql/data 然后创建mysql的配置文件 1vi /opt/docker/mysql/conf/my.conf 添加如下配置 12345678[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 准备好我们便可以创建容器。 创建容器创建容器（就是这行命令从零启动了mysql服务） 1docker run -d -p 3306:3306 --privileged=true -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf -v /opt/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-dev mysql:5.7 命令说明： -p 3306:3306 将容器的 3306 端口映射到主机的 3306 端口，宿主机:容器 -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf 将主机/opt/docker/mysql/conf/my.conf挂载到容器的 /etc/mysql/my.cnf -v /opt/docker/mysql/data:/var/lib/mysql 将主机/opt/docker/mysql/data挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 初始化 root 用户的密码 --name mysql-dev 为容器命名 然后通过docker ps命令就可以查看正在运行的docker服务 123[root@localhost /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 9 days ago Up 26 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 用你喜欢的数据库可视化工具去连接mysql服务，successful !!! 使用docker启动redis如果我们本地没有镜像，在启动redis服务的时候，会自动尝试pull，所以我们可以通过一行命令就能启动redis服务。如果通过第二种方式启动的话，需要提前准备redis的配置文件 首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 123mkdir /opt/docker/redismkdir /opt/docker/mysql/confmkdir /opt/docker/mysql/data 然后去下载一个对应版本的redis.conf，放到下面目录中 1/opt/docker/redis/conf/redis.conf 然后需要修改以下几点： 注释bind 127.0.0.1 注释掉daemonize yes ，或者设置为：daemonize no 如果要设置密码：requirepass your-password 设置数据持久化：appendonly yes 1234# 启动一个redis服务docker run -d -p 6379:6379 --name redis-dev redis:4.0# 启动redis并挂载外部conf，需自己去官网下载redis.confdocker run -d -p 6379:6379 -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /opt/docker/redis/data:/etc/redis/data --name redis-dev redis:4.0 redis-server /etc/redis/redis.conf 然后通过docker ps查看处于活跃状态的docker服务 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c5ed64050de redis:4.0 &quot;docker-entrypoint...&quot; 3 minutes ago Up 3 minutes 0.0.0.0:6379-&gt;6379/tcp redis-devf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 13 days ago Up 24 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 其他说明一般使用redis会做高可用，设置密码，挂载外部的data以及conf，做数据持久化，以下是对上述命令做一些解释以及补充， -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf：挂载配置文件 -v /opt/docker/redis/data:/etc/redis/data：映射data目录 redis-server /etc/redis/redis.conf：服务使用指定的配置文件 --name mysql-dev 为容器命名 --privileged=true：赋予容器内的root拥有真正root权限 --requirepass &quot;pwd&quot;：给redis设置密码（如果挂载了外部的配置文件并设置过了，就无需再次设置） --appendonly yes：开启数据持久化（如果挂载了外部的配置文件并设置过了，就无需再次设置）","link":"/2018/10/01/docker-in-action-03/"},{"title":"Java8 lambda 实战","text":"本篇内容摘自《Java8 实战》 在阅读本篇文章之前，我希望你能了解什么是行为参数化——它允许你定义一个代码块来表示一个行为，然后传递它，利用这个概念，你就可以编写更为灵活且可重复使用的代码。 在行为参数化那篇博客中，我们最后写出了这样的代码 123456789101112131415161718192021public class Demo4 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这里有一个问题，我们要筛选绿色苹果的时候编写了一个类AppleGreenColorPredicate去实现ApplePredicate接口，但是有时候这个方法可能只会使用一次，如果这时候还要按照上面的方法去做的话，就显得有些不太合适。那么我们要如何去做呢？这时候我们想到了一个匿名内部类，代码如下 12345678910111213141516171819202122232425262728public class Demo5 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), new ApplePredicate() { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); } }); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这样我们就可以不用创建一个实现类去实现ApplePredicate接口，但是匿名内部类不太友好，它占用了很多空间，让我们的代码显得很笨重与啰嗦，让代码显得不那么易读。那有没有办法去解决这个问题呢，答案是有的，在java8中，我们可以使用lambda表达式 去改造之前的代码，如下 1234567891011121314151617181920212223public class Demo6 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), apple -&gt; \"green\".equals(apple.getColor())); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 我想你应该发现了，之前匿名内部类的地方被这样一句代码代替了——apple -&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的左边是参数列表，apple是简写，我们可以写成这样——(Apple apple)-&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的右边是函数主体，这样写让我们的代码变得简洁很多。之所以我们能使用lambda表达式是依赖于类型推断，这是由编译器通过上下文环境推断而出。 比如我们要对苹果的重量从大到小进行排序 12345public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight)); apples.forEach(System.out::println); } 当苹果的重量一样，我们按照苹果的颜色来排序也是可以做到的，如下 1234567public class Demo7 { public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight).thenComparing(Apple::getColor)); apples.forEach(System.out::println); }} 未完待续。。。","link":"/2018/08/12/java8-lambda/"},{"title":"Java8 Stream实战（二）","text":"前言实际工作中，我们面临的数据处理场景异常复杂，往往需要多种API组合使用。对于常见的处理需求，Java8提供了例如 Collectors 来协助我们处理集合，比如我们需要将流收集成一个ArrayList 的时候，我们可以直接使用java.util.stream.Collectors#toList，如下 1List collect = students.stream().collect(Collectors.toList()); 但是 Collectors#toList 的实现相较于上面的函数式编程API，显得不那么简单明了，反而有些复杂： 1234public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() { return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; { left.addAll(right); return left; }, CH_ID); 对于源码这里就不过多介绍，本次主要是记录工作中一些常见的数据处理场景中，一起看看Stream是如何体现其优势的。 Stream in action自定义分组 自定义分组（Map）的key &amp; value 12345// 根据学生编号分组，value为学生的姓名Map&lt;String, List&lt;String&gt;&gt; collect = students.stream().collect(Collectors.groupingBy( Student::getStudentNo, Collectors.mapping(Student::getName, Collectors.toList()))); collect.forEach((k, v) -&gt; System.out.printf(\"studentNo: [%s], name: %s \\n\", k, v)); 自定义去重利用Set去重1234567@Testpublic void generateTest2() { Set&lt;Student&gt; collect = students.stream().collect( Collectors.toCollection( () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getId))));} 上述是将 List 转换成 Set，从而利用 Set 的特性来完成去重，如果想收集的对象是 List ，可以参考下面代码： 1234List&lt;Student&gt; collect = students.stream().collect(Collectors.collectingAndThen( Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Student::getStudentNo))), ArrayList::new));collect.forEach(System.out::println); List 转换 Map工作中我们经常遇到根据ID 或者其他一些标识符将List转成Map的场景，对象的一个属性作为key，用来避免例如嵌套for循环。利用 Collectors#groupingBy 可以达到分组的效果，但是获取到的是 Map&lt;K, List&lt;V&gt;&gt; ,不方便我们使用，尽管有时候我们是根据主键（唯一）来分组，对于这样的key，只会存在一个value与之对应。那么我们如何获取到 Map&lt;K, V&gt; 呢，我们可以使用 Collectors#toMap ，JDK1.8中 toMap有三个重载方法， 1、如果能保证一个key只会对应一个value 1234Map&lt;String, String&gt; collect = STUDENTS.stream() .collect(Collectors.toMap(Student::getStudentNo, Student::getName));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v)); 2、如果一个key可能对应多个value（只保留其中一个value） 1234Map&lt;String, String&gt; collect = STUDENTS.stream().collect(Collectors.toMap( Student::getStudentNo, Student::getName, (s1, s2) -&gt; s1));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v)); 3、如果一个key可能对应多个value（只保留其中一个value），但是想以非HashMap 来作为容器 1234Map&lt;String, String&gt; collect = STUDENTS.stream().collect(Collectors.toMap( Student::getStudentNo, Student::getName, (s1, s2) -&gt; s1, TreeMap::new));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v));","link":"/2019/05/26/stream-in-action-02/"},{"title":"构建Spring Boot Starter(二)","text":"注：案例工程使用的spring boot 版本为 2.1.2.RELEASE，Java 版本为 1.8 熟悉spring boot的人肯定对 application.yml 或者 application.properties 配置文件很眼熟（因为个人喜好yaml方式，所以以下示例选用application.yml），因为spring boot 有着约定大于配置的特性，所以当其默认的配置不是我们需要的时候，就可以在工程的resource 目录下找到application.yml 进行相关配置，然后启动程序，这时spring boot便会按照新的配置去运行。 例如 springboot 默认启动端口时8080，如果我们的机器8080端口已被使用，那么就要配置一个未被使用的端口，这是我们只要在application.yml 中填写如下配置： 12server: port: 18080 然后启动程序…… 1[ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 18080 (http) with context path &apos;&apos; 通过控制台日志我们可以发现，此时spring boot程序的端口已被修改为18080。 这种开发方式在spring boot中随处可见，比如如上所示的设置端口，或者如下所示的开启spring-cloud-gateway 通过注册中心自动创建路由，只需要进行如下配置即可： 123456spring: cloud: gateway: discovery: locator: enabled: true 而我们也可以模仿这种开发方式，让我们的程序更加灵活。所以本篇博客将讲述如何在 springboot 2.x 中读取配置文件。 读取application.yml1. @Value在spring boot 2.x中，如果我们需要读取配置文件，如下面这种形式的配置， 12bfh: name: BFH 可以通过 @Value 注解来实现，如下： 1234567@Value(\"${bfh.name}\")private String name;@GetMapping(\"getValueOfName\")public String getValueOfName() { return name;} 获取配置：curl -X GET &quot;http://127.0.0.1:18080/getValueOfName 2. @ConfigurationProperties@Value 注解虽然好用，但是不支持集合，IDEA 也不能做到智能提示，不管是造轮子，还是平时项目开发都建议使用 @ConfigurationProperties 注解，这样较为规范，接下来将介绍如何使用。 123456789@Data@Component@ConfigurationProperties(prefix = \"bfh\")public class DemoProperties { private String name = \"bfh\"; private Set&lt;String&gt; ips = new LinkedHashSet&lt;&gt;();} 注：其中属性名要对应配置文件中的属性，比如这里面的name属性，对应配置文件中的bfh.name 如果除去注解不看的话，那么这只是一个普通的简单Java类，首先我们使用 @ConfigurationProperties(prefix = &quot;bfh&quot;) 来读取 application.yml 中前缀为 bfh 的配置，使用lombok 的 @Data 来提供必要的 getter setter 方法，最后使用 @Component 将其注入 spring 容器。 我们在 application.yml 添加一些配置数据： 12345678bfh: name: BFH ips: - 127.0.0.1 - 127.0.0.2 - 127.0.0.3 - 127.0.0.4 - 127.0.0.5 在我们需要读取配置文件的地方注入之前编写好的 DemoProperties 通过相应的get方法就能获取到配置信息： 123456789101112@Autowiredprivate DemoProperties properties;@GetMapping(\"getStarterIps\")public Set&lt;String&gt; getStarterIps() { return properties.getIps();}@GetMapping(\"getStarterName\")public String getStarterName() { return properties.getName();} 读取自定义yml配置文件首先我们创建一个 YamlPropertyLoaderFactory ，代码如下： 123456789101112public class YamlPropertyLoaderFactory extends DefaultPropertySourceFactory {@Overridepublic PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { if (resource == null) { super.createPropertySource(name, resource); } return new YamlPropertySourceLoader().load(resource.getResource().getFilename(), resource.getResource()).get(0); }} 然后我们准备一个 CommonProperties ，和读取 application.yml不同的是，读取自定义的yml文件，我们需要增加一个注解来指定一下读取的配置文件位置信息，@PropertySource(value = &quot;classpath:common.yml&quot;, factory = YamlPropertyLoaderFactory.class) ，代码如下： 12345678910@Data@Component@PropertySource(value = \"classpath:common.yml\", factory = YamlPropertyLoaderFactory.class)@ConfigurationProperties(prefix = \"common\")public class CommonProperties { private String name = \"common\"; private Set&lt;String&gt; list = new LinkedHashSet&lt;&gt;();} 获取配置信息的方式如下： 123456789101112@Autowiredprivate CommonProperties commonProperties;@GetMapping(\"getCommonList\")public Set&lt;String&gt; getCommonList() { return commonProperties.getList();}@GetMapping(\"getCommonName\")public String getCommonName() { return commonProperties.getName();} 相关案例代码移步 blog-samples 。 欢迎 watch star fork toolkit-spring-boot-project ，一个好用的，开箱即用的工具集。","link":"/2019/02/15/build-spring-boot-starter-02/"},{"title":"lombok 实战","text":"其实早就听过lombok，作为java开发者心中奇技淫巧，确实给我们开发带来了很多便捷。很多大牛也写博客对其进行详细的介绍，文章末尾会给出一些文章链接以供学习，而本篇文章记录下本人在接触、使用lombok后的一些心得。 lombok 介绍作为一个java开发者，我们日常开发过程中无法避免类似getter or setter 这样的代码出现在我们的工程中，又或是引用日志的时候无法避免每个文件中都写一遍 1private Logger log = LoggerFactory.getLogger(this.getClass()); 也有人为了解决这个问题，将其封装成一个工具类，让我们可以通过LogUtil.info(&quot;log&quot;)这样进行日志的输出，但是使用过的人也许会发现，一般我们打印的日志，日志会输出日志所在类的路径，但是我们使用LogUtil工具类来帮我们输出的话，日志只输出该工具类的路径（当然可以用反射来输出调用LogUtil类的路径），不方便bug排查。 准备工作使用lombok前需要做两件事： 1、首先是在我们使用的IDE中，安装lombok插件，我这边介绍IDEA的按照过程， 1File &gt; Settings &gt; Plugins &gt; Browse repositories 然后搜索Lombok Plugin ，然后点击右边绿色的install 按钮进行安装，安装后需要重启IDEA。 2、在maven工程中引入lombo 的依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 接下来就进入激动人心的lombok实战环节。 lombok注解1、@Slf4j我们不用自己显示获取log对象，不用自己封装工具类去输出日志，一个注解帮我们搞定 12345678// private Logger log = LoggerFactory.getLogger(this.getClass());@Slf4jpublic class LogTest { public static void main(String[] args) { log.info(\"==&gt; \" + LocalDateTime.now()); }} 2、@Data虽然使用IDE为我们的pojo生成getter、 setter或者toString这些方法对我们来说习以为常，但是在代码中嵌入一堆getter、 setter方法显得不那么优雅，而且我们添加或者修改属性就要重新生成对于的getter、 setter方法，所以这里我们可以使用@Getter，@Setter注解来帮我们做这些事 1234567891011121314151617181920212223242526272829303132333435363738394041@Getter@Setterpublic class LombokPerson { private Integer id; private String name; private String sex;}// 使用idea，jdk1.8 反编译class文件得到如下代码public class LombokPerson { private Integer id; private String name; private String sex; public LombokPerson() { } public Integer getId() { return this.id; } public String getName() { return this.name; } public String getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public void setName(String name) { this.name = name; } public void setSex(String sex) { this.sex = sex; }} 其实我们还可以直接在类上使用@Data注解，它的作用比较全，包含了@ToString，@EqualsAndHashCode，所有字段的@Getter和所有非final字段的@Setter, @RequiredArgsConstructor，所以我们直接使用@Data注解来替换之前的@Getter，@Setter注解 123456@Datapublic class LombokPerson { private Integer id; private String name; private String sex;} 这里除了getter，setter方法外，还会生成equals、canEqual、hashCode、toString，由于代码篇幅较长，这里就不贴出编译后的字节码了，大家可以自行测试 3、@NonNull其实对于NEP（NullPointerException，后文采用简称NPE），java8已经引入了Optional来尝试解决这个问题，但是这并没有强制检查，使用不当还是会导致NPE，如果你直接使用get方法去获取Optional中包装的空值。 而lombok提供的@NonNull，是帮我写了非空判断 123456789101112131415161718public class Demo01 { public static void main(String[] args) { String str = null; checkNull(str); } public static void checkNull(@NonNull String msg) { System.out.println(msg.length()); }}// 下面是反编译的class文件public static void checkNull(@NonNull String msg) { if (msg == null) { throw new NullPointerException(\"msg is marked @NonNull but is null\"); } else { System.out.println(msg.length()); }} 可以看到lombok帮我添加了一个if判断，如果为空，就抛一个NPE。不过这里和Optional的设计理念不一样，Optional想从根源上去解决Null这个问题，而lombok的@NonNull只是保证了程序调用对象方法的时候，会对对象是否为空进行检查，如果为空就抛NPE。 那么使用和不使用都是会抛NPE，那么@NonNull 有什么用处呢，其实通过输出的异常堆栈我们就知道，使用 @NonNull使我们能够快速定位到错误出现的地方msg is marked @NonNull but is null 123456// 使用 @NonNullException in thread \"main\" java.lang.NullPointerException: msg is marked @NonNull but is null // 不使用 @NonNullException in thread \"main\" java.lang.NullPointerException 4、@Accessors在介绍生成器模式之前，我们可以试试链式调用风格来初始化我们的对象： 12345678910111213141516171819@Accessors(chain = true)@Setter@Getter@ToStringpublic class Person { private Integer id; private String name;}// 使用@Testpublic void accessorsTest() { Person person = new Person(); person.setId(100).setName(\"jack\"); System.out.println(person);} 为什么我们能连续set来形成链式 调用呢，通过反编译Person.class可以知道，在我们调用Person#setId的时候，给我返回了对象本身–this，所以我们可以继续调用对象的其他set方法。 1234567891011121314151617181920212223242526272829public class Person { private Integer id; private String name; public Person() { } public Person setId(Integer id) { this.id = id; return this; } public Person setName(String name) { this.name = name; return this; } public Integer getId() { return this.id; } public String getName() { return this.name; } public String toString() { return \"Person(id=\" + this.getId() + \", name=\" + this.getName() + \")\"; }} 5、@Builder说到生成器模式我们有些同学可能会感到陌生，但是类似下面这样的代码，我们肯定遇到过 1234Request request = new Request.Builder() .post(body) .url(url) .build(); 这是OkHttp构建request对象的api，这种方式来初始化对象并赋值的方式看起来比较优雅，这里我们可以借助lombok提供的@Builder 注解实现，如下： 123456789101112131415161718@Builder@ToStringpublic class LombokPerson2 { private Integer id; private String name; private String sex;}// 测试代码public static void main(String[] args) { LombokPerson2 person2 = LombokPerson2 .builder() .id(1) .name(\"laoWang\") .sex(\"男\") .build(); System.out.println(person2);} 目前我日常使用的几个注解已经介绍完毕，当然lombok提供的功能不止这些，如果你有兴趣可以自己搜索或者翻看下面这两篇博客。 Lombok：让JAVA代码更优雅 Java开发神器Lombok的使用与原理","link":"/2018/08/26/lombok/"},{"title":"使用Spring Cloud Gateway替换Zuul","text":"前言随着 Spring Cloud Netflix 家族宣布进入维护阶段，我也准备将 spinrg-cloud-in-action 进行相应的调整，计划使用 Spring Cloud Gateway 替代 Zuul，使用 Resilience4j 替换目前使用的 Hystrix ，这篇博客记录下整合 Spring Cloud Gateway 的一些过程。 Spring Cloud Gateway什么是 Spring Cloud Gateway ？ Spring Cloud Gateway 提供了一个建立在Spring Ecosystem之上的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。 Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为他们提供横切关注点，例如：安全性，监控/指标和弹性。 为什么要使用 Spring Cloud Gateway ？ 首先 Zuul 是基于servlet构建，使用阻塞API。它不支持任何长连接，如 websockets。 Spring Cloud Gateway 基于Spring Framework 5，Project Reactor 和 Spring Boot 2构建，使用非阻塞API。支持Websockets，而且它与 Spring 紧密集成，因此它能给开发人员带来更好的开发体验。 接下来讲介绍如何在项目中引入 Spring Cloud Gateway。 引入Spring Cloud Gateway首先我们在工程中引入相关依赖（以Maven为例） 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 不同于Zuul需要在启动类上添加 @EnableZuulProxy，使用spring cloud gateway我们无需通过注解开启网关功能，只需要在网关模块的application.yml中添加如下配置，便可开启通过服务中心自动（根据 serviceId ）创建路由。 123456spring: cloud: gateway: discovery: locator: enabled: true 远程调用选用的是 feign ，所以我们需要在 pom 文件中引入 feign 的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 通过在启动类上添加注解 @EnableFeignClients ，启用feign。关于远程调用这块的使用，和我们使用网关是什么没有关系，还是按照之前的使用方法，如下： 1234567@FeignClient(name = \"provider\")public interface HelloControllerRemote { @PostMapping(\"/hello\") String hello(@RequestParam(\"userName\") String userName);} @FeignClient(name = &quot;provider&quot;) 指定我们调用哪个微服务模块，通过 @PostMapping(&quot;/hello&quot;) 等来绑定调用的哪个接口。这样我们就可以在我们的 ConsumerHelloController里面注入该 HelloControllerRemote ,如下： 12345678910111213@RestControllerpublic class ConsumerHelloController { @Autowired private HelloControllerRemote helloControllerRemote; @ApiOperation(\"hello接口\") @PostMapping(\"/hello\") public String hello(@ApiParam(\"用户名\") String userName) { return helloControllerRemote.hello(userName); }} 验证 1curl -X PUT http://localhost:9999/CONSUMER/hello 注：我目前使用的是 spring-cloud-gateway-2.1.0.RELEASE ，使用feign调用consumer模块的接口，无法通过/consumer/hello 远程访问，而是调用 /CONSUMER/hello ，模块名需要大写。 整合swagger因为Spring Cloud Gateway 是基于webflux和Netty，而swagger(version: 2.9.2)目前还没有提供支持，所以我们要用webflux的方式提供swagger对外接口， 123456789101112131415161718192021222324252627282930@Componentpublic class SwaggerRouterFunction { @Autowired(required = false) private SecurityConfiguration securityConfiguration; @Autowired(required = false) private UiConfiguration uiConfiguration; @Autowired private SwaggerResourcesProvider swaggerResources; @Bean public RouterFunction&lt;?&gt; routerFunction() { return RouterFunctions .route(GET(\"/swagger-resources\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(swaggerResources.get()))) .andRoute(GET(\"/swagger-resources/configuration/ui\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(Optional.ofNullable(uiConfiguration) .orElse(UiConfigurationBuilder.builder().build())))) .andRoute(GET(\"/swagger-resources/configuration/security\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(Optional.ofNullable(securityConfiguration) .orElse(SecurityConfigurationBuilder.builder().build())))); }} 除此之外，我们还要聚合swagger文档，需要提供 swaggerResource list ，我们是从RouteLocator中获取到routes信息，来实现自动聚合： 12345678910111213141516171819202122232425262728293031323334353637@Primary@Componentpublic class SwaggerProvider implements SwaggerResourcesProvider { @Value(\"${spring.application.name}\") public String applicationName; private final RouteLocator routeLocator; public SwaggerProvider(RouteLocator routeLocator) { this.routeLocator = routeLocator; } @Override public List&lt;SwaggerResource&gt; get() { List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;(); routeLocator.getRoutes().subscribe(route -&gt; { String routeUri = route.getUri().getHost(); if (!applicationName.equalsIgnoreCase(routeUri)) { resources.add(swaggerResource(routeUri, String.format(\"/%s/v2/api-docs\", routeUri))); } }); return resources; } private SwaggerResource swaggerResource(String name, String location) { SwaggerResource swaggerResource = new SwaggerResource(); swaggerResource.setSwaggerVersion(\"2.0\"); swaggerResource.setName(name); swaggerResource.setLocation(location); return swaggerResource; }} 然后我们启动注册中心，网关，provider，consumer 4个模块，访问 http://localhost:9999/swagger-ui.html#/ ，便能看到文档聚合后的效果。 源码详细代码见 spring-cloud-in-action","link":"/2019/03/09/spring-cloud-gateway-01/"},{"title":"Java源码解读(一)：Objects","text":"其实阅读Java源码本身并没有那么难，只要我们踏出第一步，后面反而比我们想象的要简单。可能很多Java初学者并不知道从哪里下手，所以本篇博客将挑选一个源码较为简单的工具类—— java.util.Objects 作为切入点，走入Java源码的世界。 相关说明 IDE： IDEA Java Version： 1.8.0_161 ObjectsObjects 位于 java.util 包下，看名称就能知道是一个工具类，除去私有的构造方法外，只有12个静态方法供我们使用，为了方便阅读，这里我已经去掉注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package java.util;import java.util.function.Supplier;public final class Objects { private Objects() { throw new AssertionError(\"No java.util.Objects instances for you!\"); } public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;&amp; a.equals(b)); } public static boolean deepEquals(Object a, Object b) { if (a == b) return true; else if (a == null || b == null) return false; else return Arrays.deepEquals0(a, b); } public static int hashCode(Object o) { return o != null ? o.hashCode() : 0; } public static int hash(Object... values) { return Arrays.hashCode(values); } public static String toString(Object o) { return String.valueOf(o); } public static String toString(Object o, String nullDefault) { return (o != null) ? o.toString() : nullDefault; } public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c) { return (a == b) ? 0 : c.compare(a, b); } public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } public static &lt;T&gt; T requireNonNull(T obj, String message) { if (obj == null) throw new NullPointerException(message); return obj; } public static boolean isNull(Object obj) { return obj == null; } public static boolean nonNull(Object obj) { return obj != null; } public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) { if (obj == null) throw new NullPointerException(messageSupplier.get()); return obj; }} 看上去很熟悉，并不会很陌生对吧，其实阅读源码也没有想象的那么难。 构造方法这个工具类首先引入眼帘的便是其私有的构造方法： 123private Objects() { throw new AssertionError(\"No java.util.Objects instances for you!\");} 如果你有阅读上面的源码就会发现，Objects 提供的方法除此外皆为静态方法，当我们使用这些方法的时候无需显示实例化对象，而是直接通过 类名.方法名() 来调用其提供的方法，而私有其构造方法便是以防我们无意义创建对象浪费空间，所以这里抛出一个断言异常—— &quot;No java.util.Objects instances for you!&quot;。 说到构造方法私有化想必大家有点耳熟，没错，我们在学习单例模式的时候便将对象的构造方法私有化，不允许用户去 new 该对象，而是通过我们提供的方法去获取已经创建好的实例。 equals接下来我们正式开始介绍 Objects 最为常用的方法 equals ： 123public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;&amp; a.equals(b));} 这也很简单对吧，我们也写过这样的代码，判断两个对象是否相等，代码就一行，翻译一下就是判断参数列表中的两个对象是否为同一个对象（引用是否指向同一内存地址），或者在参数 a 不为 null 的情况下，调用 a 的 equals 方法，而a的 equals 方法要看其具体的实现，如果是Object（所有对象的父类），则： 1234public boolean equals(Object obj) { // 判断是否为同一对象，即引用是否指向同一内存地址 return (this == obj);} equals of String但这不能满足我们日常使用需求，实际开发过程中，假如 Student 的 id 相同，那么我们就可以认为 equals 为 true ，所以Object的equals方法并不能满足这种情况，所以有必要的时候大家都会重写一下equals方法（重写 equals 方法的同时最好重写一下 hashCode ），这里就介绍一下String的equals实现（为了方便阅读，我添加了些许注释）： 1234567891011121314151617181920212223242526272829public boolean equals(Object anObject) { if (this == anObject) { // 判断是否为同一对象 return true; } if (anObject instanceof String) { // 如果anObject是String的实例（通俗来讲就是String是否为String类型） // 如果是，则强转为String类型（通过instanceof判断避免类型转化异常） String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { // 其实阅读过String源码我们就明白这里的用途（String底层使用的是char[]数组） // 1、判断底层数组的长度，如果不想等说明两个字符肯定不一样，就无需继续判断 // 2、如果是，一个字符一个字符去判断是否相等 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // 从最后一个字符开始对比 if (v1[i] != v2[i]) // 如果同一位置的字符不相等，则字符串不相等 return false; i++; } return true; } } return false; } 可能大家对最后一段 while 那里有点疑惑，其实我们完全可以用 for 来替代 while ： 123456789101112131415int n = value.length;...int i = 0;while (n-- != 0) { if (v1[i] != v2[i]) return false; i++;}// 上面while的写法可以用for改写for (int i = 0; i &lt; value.length; i++) { if (v1[i] != v2[i]) { return false; }} 其实第一次看到 String 的 equals 方法就差点笑出声，感觉这个作者写的小心翼翼（提高性能），判断字符串是否相等经历如下步骤： 判断两个对象是否相等，对象都想相等了，我们还用判断吗？ 什么？对象不相等，那么只能遍历 char[] 一个个字符去判断了。。。不对！如果数组长度不一样那肯定也不相等，所以我们在循环前线判断一下字符串底层数组的长度吧。 oops！连底层数组长度都一样，这下没办法了，老老实实去一个个判断吧，还好只要判断相同位置上的字符是否相等就行，一个 for 循环搞定！ 说好的阅读 Objects 源码，去花费大量篇章去介绍 String 的 equsla 方法了，赶紧回到正题。 其实Objects.equals() 实现还是通过调用其 参数的自身实现，不过在这之前贴心的帮我们做了非空判断以及一些优化—— a == b ，没错，就是这个小小的 a == b ,为什么说是优化呢？首先是避免空指针异常，其次是通过String的equals方法我们知道，判断两个字符串是否相等的原理是一个一个去对比其底层char数组里面的元素，但是如果a b 是同一对象，我们判断其内存地址便可，比对底层数组里面的元素未免显得有些浪费性能了。 其他篇幅有限，其他方法无法一个个扩展开来去讲，就稍微介绍一下吧： deepEquals 是通过Arrays.deepEquals0() 来支持两个数组是否相等（顺序），如果对象不是数组，则返回false； hashCode 调用了对象自身的 hashCode 实现 hash 调用了Arrays.hashCode 的实现，来计算数组的 hash 值 toString 是调用了 String.valueOf 方法,这点和Object 的实现不一样（Object 为getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) ） oString(Object o, String nullDefault) 如果对象本身不为空则调用其toString方法，为空就使用其默认值nullDefault compare(T a, T b, Comparator&lt;? super T&gt; c) 方法，如果我们了解过Java8的新特性就会知道这么一个词——行为参数话，就拿Student 对象来举例，compare两个Student，我们可以compare的属性有很多，比如年龄，身高，成绩等等。这样就导致一个compare方法我们可能要重载多次，但是通过行为参数化，我们将比较的这个行为（比较年龄？比较身高？）当作参数传入，就只用写一个compare方法，比如这里面的最后一个参数——Comparator&lt;? super T&gt; c，这是一个函数式接口，是我们进行对象比较的具体行为，可以参考我之前写的 行为参数化 这篇文章 以及一些针对null封装的一些方法，自行阅读即可。 Java的源码解读是我很早就想做的一件事，但由于自身水平所限，写出来的文章达不到我理想的效果，请多见谅。","link":"/2019/01/13/source-of-objects-in-java/"},{"title":"Java8 Stream实战（一）","text":"参考自《Java 8实战》 什么是stream为什么使用Stream？因为它能让我们更高效地处理集合，让我们可以简洁地表达复杂的数据处理查询。此外，Stream可以透明地并行化。我们可以使用Stream API完成以下操作： 可以表达复杂的数据处理查询 可以使用filter、distinct、skip和limit对流做筛选和切片 可以使用map和flatmap提取或转换流中的元素 可以使用findFirst和findAny方法查找流中的元素 可以使用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词 可以使用reduce方法将流中的所有元素 迭代合并成一个结果 除此之外我们应该知道，流不仅可以 从集合创建，也可以从值、数组、文件以及iterate与generate等特定的方法创建。 stream实践准备工作创建交易员实体类： 1234567891011121314151617181920212223242526public class Trader { private String name; private String city; public Trader(String name, String city) { this.name = name; this.city = city; } public String getName() { return name; } public String getCity() { return city; } @Override public String toString() { return \"Trader{\" + \"name='\" + name + '\\'' + \", city='\" + city + '\\'' + '}'; }} 创建交易记录实体类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction { private Trader trader; private int year; private int value; public Transaction(Trader trader, int year, int value) { this.trader = trader; this.year = year; this.value = value; } public Trader getTrader() { return trader; } public void setTrader(Trader trader) { this.trader = trader; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } @Override public String toString() { return \"Transaction{\" + \"trader=\" + trader + \", year=\" + year + \", value=\" + value + '}'; }} 这里我增加了一个工具类，用于获取测试demo所需的集合： 12345678910111213141516171819public class ListUtil { public static List&lt;Transaction&gt; getList() { Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); return Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); }} 编码1、找到2011年发生的所有交易，并按交易额排序（从低到高） 12345678910111213141516public class Demo01 { public static void main(String[] args) { List&lt;Transaction&gt; collect = ListUtil.getList() .stream() .filter(n -&gt; n.getYear() == 2011) .sorted(Comparator.comparing(Transaction::getValue)) /// 从高到低 //.sorted(Comparator.comparing(Transaction::getValue).reversed()) .collect(Collectors.toList()); collect.forEach(System.out::println); }} 2、交易员都在哪些不同的城市工作过 123456789101112131415public class Demo02 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(n -&gt; n.getTrader().getCity()) .distinct() /// 返回一个List //.collect(Collectors.toList()); .collect(Collectors.joining(\", \")); System.out.println(collect); }} 3、查找所有来自剑桥的交易员并按照姓名排序 123456789101112131415public class Demo03 { public static void main(String[] args) { List&lt;Trader&gt; cambridge = ListUtil.getList() .stream() .map(Transaction::getTrader) .filter(trader -&gt; \"Cambridge\".equals(trader.getCity())) .distinct() .sorted(Comparator.comparing(Trader::getName)) .collect(Collectors.toList()); cambridge.forEach(System.out::println); }} 4、返回所有交易员的姓名字符串，按照字母顺序排序 1234567891011121314public class Demo04 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .sorted(String::compareTo) .collect(Collectors.joining(\", \")); System.out.println(collect); }} 5、有没有交易员是在米兰工作的 12345678910111213141516171819public class Demo05 { public static void main(String[] args) { ListUtil.getList() .stream() .filter(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())) .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .forEach(System.out::println); // 参考 boolean b = ListUtil.getList() .stream() .anyMatch(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())); System.out.println(b); }} 6、打印生活在剑桥的交易员的所有交易额 123456789101112131415161718192021public class Demo06 { public static void main(String[] args) { // 总交易额 int sum = ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .mapToInt(Transaction::getValue) .sum(); System.out.println(\"总交易额: \" + sum); // 参考 ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .map(Transaction::getValue) .forEach(System.out::println); }} 7、所有的交易额中，最高的交易额是多少 12345678910111213141516171819202122232425262728public class Demo07 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue).reversed()) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 OptionalInt reduce = ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max); if (reduce.isPresent()) { System.out.println(reduce.getAsInt()); } // 参考 ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max) .ifPresent(System.out::println); }} 8、找到交易额中最小的交易额 12345678910111213141516171819public class Demo08 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue)) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 ListUtil.getList() .stream() .map(Transaction::getValue) .reduce(Integer::min) .ifPresent(System.out::println); }} 至此，关于stream的8个demo介绍完毕，这只是简单的介绍用法，关于stream还有很多东西值得我们去探索，像stream的筛选和切片、映射、查找和匹配、规约、以及各类收集器（我们甚至可以自定义收集器）。后续我会陆续更新，敬请期待。。。","link":"/2018/08/13/stream-in-action-01/"}],"tags":[{"name":"java8","slug":"java8","link":"/tags/java8/"},{"name":"annotation","slug":"annotation","link":"/tags/annotation/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"stream","slug":"stream","link":"/tags/stream/"},{"name":"yaml","slug":"yaml","link":"/tags/yaml/"},{"name":"lombok","slug":"lombok","link":"/tags/lombok/"},{"name":"spring-cloud-gateway","slug":"spring-cloud-gateway","link":"/tags/spring-cloud-gateway/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"spring-boot","slug":"spring-boot","link":"/categories/spring-boot/"},{"name":"spring-cloud","slug":"spring-cloud","link":"/categories/spring-cloud/"},{"name":"源码","slug":"源码","link":"/categories/源码/"}]}