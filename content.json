{"pages":[{"title":"About","text":"作为一个顶天立地的人，你要无怨无悔地走完自己的人生历程。想要怎样才能充实地走完这段历程，这是一个值得思考的问题。是碌碌无为，虚度韶华？还是踏踏实实，拼搏奋斗？这取决于自己。要想成就理想，需要做到不唯众，不唯上。不在意普通的路上是否比别人走得更快，而是又在无人行走的荒野上行走的勇气，这样才能看到别人无法看到的情境。 关于我一枚程序员，这是我对自己现阶段的描述。 虽然文笔一般，但是我还是想写点东西记录些什么，包括学习过程中的一些感悟。 至于写博客，也不算是一时间的心血来潮，很久之前就有过这样的想法，也尝试过很多种方式，最终以现在这种方式呈现出来。 持续更新中… 读书目录 Java编程思想 Java8实战 Spring Cloud微服务实战 Powered by Hexo. Theme by PPOffice","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"自定义注解实战（一）","text":"利用AOP实现注解个人见解：使用aop最大的好处是不侵入业务代码，就可以在方法执行前或者执行后来实现某些功能，比如日志打印，权限处理等等。正是因为不侵入代码的特性，我们不建议利用aop去截断请求（request），返回包含错误信息的响应（response）。其实我之前有这么做过，自定义权限注解，用户没有权限的话，直接返回没有权限的错误信息（response），功能上可以实现，虽然给我抛异常了，有代码洁癖的我就只能使用拦截器的方法实现该注解了，利用拦截器实现注解将在 自定义注解实战（二） 中来介绍，本篇介绍利用aop来实现注解——当说明书来看吧。。。 自定义注解我们先定义一个MyAnno的注解，代码如下： 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface MyAnno { String value();} 其中，@Target(ElementType.METHOD) 定义该注解作用在方法上，使用value()我们在写注解@MyAnno的时候可以直接@MyAnno(&quot;msg&quot;),如果你按照下面的代码来定义注解的话， 123public @interface MyAnno { String param();} 那你使用注解的时候就只能@MyAnno(param = &quot;msg&quot;)了，不管是@MyAnno(&quot;msg&quot;)，还是@MyAnno(param = &quot;msg&quot;)，括号里面都要写value的，如果你定义的注解不需要写的话，那么就在定义的时候加上 default &quot;&quot;;，如下： 123public @interface MyAnno { String param() defaul \"\";} 实现注解按照上面定义完注解其实已经可以使用了，但是没什么功能，如果想让我们自定义的注解work起来，需要利用到Aspectj： 12345678910111213141516171819202122@Aspect@Componentpublic class RealizationMyAnno { @Pointcut(\"@annotation(com.bfh.annotation.MyAnno)\") public void MyMethod(){} @After(\"MyMethod()\") public void doAfterReturning(JoinPoint joinPoint){ System.out.println(\"RealizationMyAnno.doAfterReturning()\"); String targetName = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] params = joinPoint.getArgs(); // 实际开发过程中使用log打印 System.out.println(\"targetName:\" + targetName); System.out.println(\"methodName:\" + methodName); }} 这时候我们可以将我们自定义的注解加在方法上了，当程序执行到该方法时，就会打印一些信息，如果targetName，methodName，你也可以做些其他的事情，比如自动打印日志，自动将日志输出到硬盘上等等。。。 补充：其实利用aop去截断request请求也是可以的（如果必须的话），利用异常来截断请求，然后设置统一异常处理，向前端返回错误信息，不过不推荐用异常来处理业务。。。","link":"/2018/04/05/annotation-in-action-01/"},{"title":"自定义注解实战（二）","text":"利用拦截器实现注解上一篇 自定义注解实战（一） 中说到使用aop最大的好处是不侵入业务代码，但是有些业务需要拦截请求，比如参数校验，为空的话直接返回isNull的错误信息，这时候用AOP来做这件事就显得不太优雅了，所以我想到了用拦截器来实现，定义注解的方式还是一样，这里就不多加赘述了。 声明拦截器声明拦截器我们利用SpringMVC进行配置，而在mvc:interceptors标签下声明interceptor主要有两种方式： 直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。 因为利用拦截器去实现注解的话，要拦截所有请求，所以这里我们直接使用第一种方法，直接定义一个Interceptor实现类的bean对象： 123&lt;mvc:interceptors&gt; &lt;bean class=\"com.bfh.interceptor.MyAnnoInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 实现注解然后就是实现MyAnnoInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyAnnoInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.setHeader(\"Content-type\", \"application/json;charset=utf-8\"); try { if (handler instanceof HandlerMethod) { HandlerMethod method = (HandlerMethod) handler; MyAnno annotationParams = method.getMethodAnnotation(MyAnno.class); /** * 你定义的校验规则,如果通过校验，直接return true; */ } PrintWriter out = null; try { out = response.getWriter(); out.print(\"你想输出的错误信息...\"); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { if (out != null) { out.close(); } } return false; } catch (Exception e) { e.printStackTrace(); } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, org.springframework.web.servlet.ModelAndView arg3) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response,Object arg2, Exception arg3) throws Exception { }} 这样我们自定义的注解就可以使用了，至于return true还是return false，这个就看你的实际业务需求了。","link":"/2018/04/06/annotation-in-action-02/"},{"title":"行为参数化","text":"本篇内容摘自《Java8 实战》 前言行为参数化和“策略设计模式”相关，它让你定义算法，并将其封装起来（这里称为“策略”），在运行的时候选择一个算法，如果你现在不太明白这句话的意思，可以紧张兮兮的往下看，我将会通过一系列的例子来展示什么叫做行为参数化，以及这种设计模式的优点。 需求0、准备我们先准备一个苹果的实体类，重写它的toString()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Apple { /** * 苹果颜色 */ private String color; /** * 苹果重量（单位：克） */ private Integer weight; public Apple(String color, Integer weight) { this.color = color; this.weight = weight; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Integer getWeight() { return weight; } public void setWeight(Integer weight) { this.weight = weight; } @Override public String toString() { return \"Apple{\" + \"color='\" + color + '\\'' + \", weight=\" + weight + '}'; }} 然后准备一个工具类去生成测试代码所需的苹果的集合 1234567891011121314151617public class AppleUtil { public static List&lt;Apple&gt; getApples() { return Arrays.asList( new Apple(\"green\", 100), new Apple(\"green\", 120), new Apple(\"red\", 130), new Apple(\"green\", 140), new Apple(\"red\", 150), new Apple(\"green\", 160), new Apple(\"green\", 170), new Apple(\"red\", 180), new Apple(\"green\", 190), new Apple(\"red\", 200), new Apple(\"green\", 210) ); }} 至此，准备工作完成。 1、筛选绿苹果首先，我们需要从一堆苹果中筛选出绿色的苹果 12345678910111213141516171819202122public class Demo1 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterGreenApples(AppleUtil.getApples()); for (Apple apple : apples) { System.out.println(apple); } } /** * 获取绿色的苹果 * @param inventory 未筛选的苹果集合 * @return 绿色苹果的集合 */ public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"green\".equals(apple.getColor())) { result.add(apple); } } return result; }} 这很简单，我们定义了一个filterGreenApples方法，参数为List&lt;Apple&gt;，然后在方法体内遍历这个List，如果苹果是绿色的，就把这个苹果放到新的List&lt;Apple&gt;中，遍历完成后返回新的List&lt;Apple&gt;。 2、筛选红苹果有了筛选绿苹果的经历 ，我们微微一笑，将之前封装的filterGreenApples复制一份，然后改名为filterRedApples,然后修改if代码块中的代码修改为&quot;red&quot;.equals(apple.getColor()),其完整代码如下 123456789public static List&lt;Apple&gt; filterRedApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"red\".equals(apple.getColor())) { result.add(apple); } } return result; } 看上去我们“完美”的完成了任务，准备提交代码的时候，又来了一个需求，筛选一半红一半绿的苹果，这时候我们就不太想复制之前的代码了，何不将颜色作为参数传入方法中呢，说干就干 123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, String color) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (color.equals(apple.getColor())) { result.add(apple); } } return result; } 但是这里又暴露出其他问题了，比如，我要筛选出出重量大于150g的苹果，我要筛选出出重量大于150g的红苹果，那我们现有的架构也没法实现这个需求，而且封装的方法会越来越庞大，我们下面将介绍如何去解决这些我呢提。 3、代码重构首先我们写一个接口ApplePredicate 12345@FunctionalInterfacepublic interface ApplePredicate { boolean test(Apple apple);} 我们先不管这个注解，然后再写两个实现类，AppleGreenColorPredicate，AppleHeavyWeightPredicate 123456public class AppleGreenColorPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); }} 123456public class AppleHeavyWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() &gt; 150; }} 然后我们可以封装这样一个方法 123456789public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; } 测试代码 1234567public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } 具体的代码逻辑直接在ApplePredicate的实现类中实现就可以了，将具体的行为当作参数传入到方法中，这就是行为参数化。","link":"/2018/08/11/behavioral-parameterization/"},{"title":"Docker(二)：部署springboot项目","text":"Dockerfile概述Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Docker可以通过读取来自 Dockerfile的指令自动构建镜像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用、组合容器的所有命令。使用docker build 可以构建连续执行的多个指令集。 接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以docker部署springboot项目为例。 准备springboot项目首先我们通过spring initializr来构建一个springboot工程，只添加了一个HelloController，代码如下： 1234567@RestControllerpublic class HelloDockerController { @RequestMapping(\"/hello\") public String hello() { return \"hello, \" + LocalDateTime.now(); }} 可以使用docker构建插件来构建镜像，可以查考纯洁的微笑的博客来构建，这里我们直接将springboot工程打成jar包，来构建docker镜像。 首先将之前构建的springboot工程打包，这样我们就得到了一个hello-docker-0.0.1-SNAPSHOT.jar,然后我们再准备一个Dockerfile，内容如下 1234FROM java:8VOLUME /tmpADD hello-docker-0.0.1-SNAPSHOT.jar hello-docker.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/hello-docker.jar&quot;] 其中 FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 构建镜像 1docker build -t image-name . 然后我们通过docker images就能看见我们制作的docker镜像 12345REPOSITORY TAG IMAGE ID CREATED SIZEhello-docker latest 417dca81c225 8 minutes ago 672 MBdocker.io/mysql 5.7 563a026a1511 2 weeks ago 372 MBdocker.io/nginx latest c82521676580 2 months ago 109 MBdocker.io/java 8 d23bdf5b1b1b 20 months ago 643 MB 这样我们可以启动该镜像 1docker run -p 8080:8080 -t hello-docker 如果出现了端口映射错误，可以暂时关闭防火墙systemctl stop firewalld.service，然后重启docker服务service docker restart，重新启动镜像即可。 通过docker ps可以查看正在运行的项目 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScaa44939f959 hello-docker &quot;java -Djava.secur...&quot; 14 seconds ago Up 13 seconds 0.0.0.0:8080-&gt;8080/tcp trusting_brattainf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 7 days ago Up 2 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 然后通过访问http://your-ip:8080/hello，返回 1hello, 2018-09-25T13:38:53.246 即部署成功。 参考 docker docs Docker(二)：Dockerfile 使用介绍","link":"/2018/09/26/docker-in-action-02/"},{"title":"Docker(一)：hello-docker","text":"docker概述Docker是一个开发，运输和运行应用程序的开放平台。Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。 准备工作之前就打算在虚拟机安装centos来好好熟悉下linux，不过事情比较多，一直都没有去做。这次刚好打算了解一波docker，所以就把之前丢掉的linux捡起来。 首先我们准备一个centos环境，这里我安装的是CentOS-7-x86_64-Everything-1804，安装好后打算用终端模拟软件去连接，方便操作。在记忆中搜索片刻，敲下了ifconfig，不过好像我安装的这个版本没有给我安装ifconfig等命令，百度一看说是过时了，那找解决办法吧，ip addr，但是没看见熟悉的xxx.xxx.xxx.xxx，额，又去百度一看，需要我们配置网卡。 那就配置吧，按照百度来的教程，vi /etc/sysconfig/network-scripts/ifcfg-xxx，其实这个命令最后的xxx，就是我们敲ip addr后显示的2：后面的数值，1：一般是lo：，打开后将最后一个ONBOOT=no修改为ONBOOT=yes，这样便能启动网卡，然后我们重启网络服务service network restart，再敲ip addr就能看见IP地址了。 docker安装首先 运行命令yum install docker安装docker，然后我们通过docekr version来查看docker是否安装成功 12345[root@localhost ~]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: 这里能看到我们安装的版本是1.13.1。然后我们启动docker服务，将其设置为 开机启动 12service docker startchkconfig docker on 修改docker镜像仓库就像使用maven要修改镜像仓库那样，使用docker也不例外，我们可以将其修改为docker中国官方提供的registry.docker-cn.com来访问，其中包含了主流的docker镜像，通过修改/etc/docker/daemon.json文件，添加如下配置，如果是第一次安装docker，该文件中只是{}，替换如下内容即可。 1234{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;live-restore&quot;: true} hello world像我们学习编程语言的时候，第一个例子便是输出一行hello world，不过docker提供有docker版的hello world 供我们下载使用，我们通过docker pull去获取它。 123456Using default tag: latestTrying to pull repository docker.io/library/hello-world ... latest: Pulling from docker.io/library/hello-world9db2ca6ccae0: Pull complete Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for docker.io/hello-world:latest 我们可以通过docker image ls去查看我们本地安装有哪些镜像 12REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/hello-world latest 2cb0d9787c4d 6 weeks ago 1.85 kB 证明镜像下载到本地后，我们通过docker run hello-world 来运行这个镜像 1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 输出这段提示后，hello-world便自动终止了（像mysql，redis这些提供服务的镜像是不会自动终止）。 docker常用命令123456# 启动service docker start# 重启service docker restar# 停止service docker stop 参考 docker docs Docker(一)：Docker入门教程 周立–Docker系列教程","link":"/2018/09/02/docker-in-action-01/"},{"title":"构建自己的Spring Boot Starter","text":"Spring Boot Starter初印象初识Spring Boot 时，被其简化Spring应用初始搭建以及开发过程所惊艳到，基于约定优于配置的原则，我们无需从老项目中拷贝大量的xml文件来构建项目，只需利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 就能轻松启动一个Spring应用，极为便捷。 便捷之一：在使用Spring Boot之前，引入第三方jar包——如引入Mybatis的时候，我们需要在pom文件中引入多个依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;&lt;/dependency&gt; 这无疑给我们做第三方集成的时候增加了难度，但是使用Spring Boot我们只需引入一个依赖就能实现： 1234&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 这是因为 mybatis-spring-boot-starter 其本身可以理解为一个库的集合，帮我们管理了spring整合mybatis所需的依赖。 Spring Boot Starter除了帮我们处理了Spring工程中各种库之间复杂的依赖关系，但是这不是本篇博客介绍的重点。我们要实现类似启用Eureka的自动注册功能，只需在工程启动类上面加上 @EnableEurekaClient 便可开启服务注册发现功能（除了引入相关依赖以外），极为方便，而我们接下来就要实现通过注解来开启一项功能的一个Spring Boot Starter。 准备工作首先我们要了解Spring官方推荐的命名规范，其中官方starter命名： spring-boot-starter-[name] ，非官方命名： [name]-spring-boot-starter ，如这里我们给工具starter命名为 tools-spring-boot-starter 。 然后我们利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 构建一个spring boot项目，然后引入开发Spring Boot Starter核心依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt; 接下来我们实现一个能自由开启自定义全局异常处理的功能。首先定义一个 @Enable前缀的 注解，用于开启相关功能： 123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({GlobalExceptionHandler.class})public @interface EnableGlobalExceptionHandler {} 这里我们使用 @Import 注解去注入GlobalExceptionHandler，其代码如下： 1234567891011121314151617181920212223@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler { @ExceptionHandler(Exception.class) @ResponseBody public String defaultExceptionHandler(Exception e) { log.error(\"GlobalExceptionHandler#Exception: \", e); if (e instanceof BindException) { BindException validException = (BindException) e; return R.fail(BusinessEnum.ERROR.getCode(), \"参数校验异常：\" + validException.getBindingResult().getFieldErrors().get(0).getDefaultMessage(), null); } if (e instanceof BusinessException) { BusinessException businessException = (BusinessException) e; return R.fail(businessException.getCode(), businessException.getMessage(), null); } return R.fail(BusinessEnum.ERROR.getCode(), \"系统异常：\" + e, null); } } 其中 @Slf4j 是lombok提供的注解，这也是我们能直接使用 log.error(&quot;GlobalExceptionHandler#Exception: &quot;, e); 的原因 最后，我们利用 mvn install 安装到本地，便可在其他工程引入本依赖，12345&lt;dependency&gt; &lt;groupId&gt;com.github.baifenghe&lt;/groupId&gt; &lt;artifactId&gt;tools-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在主类上引用 @EnableGlobalExceptionHandler 注解，即可开启全局异常处理的功能。 最后的最后，欢迎star tools-spring-boot-starter ，一个好用的，开箱即用的工具集。","link":"/2019/01/08/build-spring-boot-starter/"},{"title":"Java8 lambda 实战","text":"本篇内容摘自《Java8 实战》 在阅读本篇文章之前，我希望你能了解什么是行为参数化——它允许你定义一个代码块来表示一个行为，然后传递它，利用这个概念，你就可以编写更为灵活且可重复使用的代码。 在行为参数化那篇博客中，我们最后写出了这样的代码 123456789101112131415161718192021public class Demo4 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这里有一个问题，我们要筛选绿色苹果的时候编写了一个类AppleGreenColorPredicate去实现ApplePredicate接口，但是有时候这个方法可能只会使用一次，如果这时候还要按照上面的方法去做的话，就显得有些不太合适。那么我们要如何去做呢？这时候我们想到了一个匿名内部类，代码如下 12345678910111213141516171819202122232425262728public class Demo5 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), new ApplePredicate() { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); } }); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这样我们就可以不用创建一个实现类去实现ApplePredicate接口，但是匿名内部类不太友好，它占用了很多空间，让我们的代码显得很笨重与啰嗦，让代码显得不那么易读。那有没有办法去解决这个问题呢，答案是有的，在java8中，我们可以使用lambda表达式 去改造之前的代码，如下 1234567891011121314151617181920212223public class Demo6 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), apple -&gt; \"green\".equals(apple.getColor())); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 我想你应该发现了，之前匿名内部类的地方被这样一句代码代替了——apple -&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的左边是参数列表，apple是简写，我们可以写成这样——(Apple apple)-&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的右边是函数主体，这样写让我们的代码变得简洁很多。之所以我们能使用lambda表达式是依赖于类型推断，这是由编译器通过上下文环境推断而出。 比如我们要对苹果的重量从大到小进行排序 12345public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight)); apples.forEach(System.out::println); } 当苹果的重量一样，我们按照苹果的颜色来排序也是可以做到的，如下 1234567public class Demo7 { public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight).thenComparing(Apple::getColor)); apples.forEach(System.out::println); }} 未完待续。。。","link":"/2018/08/12/java8-lambda/"},{"title":"Docker(三)：使用docker启动mysql & redis","text":"docker很便捷，最开始有这种感受是用一行命令去启动了mysql服务。想当初刚接触数据库那会，那么费力气的安装mysql也是服气。（捂脸哭~ 但是在启动mysql容器之前，我们需要做些准备工作，这是因为数据库本身的特殊性，我们需要将容器的数据映射到主机的目录中，这样就不担心手滑将容器删除导致数据丢失了。 准备工作首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 1234mkdir /opt/dockermkdir /opt/docker/mysqlmkdir /opt/docker/mysql/confmkdir /opt/docker/mysql/data 然后创建mysql的配置文件 1vi /opt/docker/mysql/conf/my.conf 添加如下配置 12345678[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 准备好我们便可以创建容器。 创建容器创建容器（就是这行命令从零启动了mysql服务） 1docker run -d -p 3306:3306 --privileged=true -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf -v /opt/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-dev mysql:5.7 命令说明： -p 3306:3306 将容器的 3306 端口映射到主机的 3306 端口，宿主机:容器 -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf 将主机/opt/docker/mysql/conf/my.conf挂载到容器的 /etc/mysql/my.cnf -v /opt/docker/mysql/data:/var/lib/mysql 将主机/opt/docker/mysql/data挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 初始化 root 用户的密码 --name mysql-dev 为容器命名 然后通过docker ps命令就可以查看正在运行的docker服务 123[root@localhost /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 9 days ago Up 26 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 用你喜欢的数据库可视化工具去连接mysql服务，successful !!! 使用docker启动redis如果我们本地没有镜像，在启动redis服务的时候，会自动尝试pull，所以我们可以通过一行命令就能启动redis服务。如果通过第二种方式启动的话，需要提前准备redis的配置文件 首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 123mkdir /opt/docker/redismkdir /opt/docker/mysql/confmkdir /opt/docker/mysql/data 然后去下载一个对应版本的redis.conf，放到下面目录中 1/opt/docker/redis/conf/redis.conf 然后需要修改以下几点： 注释bind 127.0.0.1 注释掉daemonize yes ，或者设置为：daemonize no 如果要设置密码：requirepass your-password 设置数据持久化：appendonly yes 1234# 启动一个redis服务docker run -d -p 6379:6379 --name redis-dev redis:4.0# 启动redis并挂载外部conf，需自己去官网下载redis.confdocker run -d -p 6379:6379 -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /opt/docker/redis/data:/etc/redis/data --name redis-dev redis:4.0 redis-server /etc/redis/redis.conf 然后通过docker ps查看处于活跃状态的docker服务 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c5ed64050de redis:4.0 &quot;docker-entrypoint...&quot; 3 minutes ago Up 3 minutes 0.0.0.0:6379-&gt;6379/tcp redis-devf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 13 days ago Up 24 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 其他说明一般使用redis会做高可用，设置密码，挂载外部的data以及conf，做数据持久化，以下是对上述命令做一些解释以及补充， -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf：挂载配置文件 -v /opt/docker/redis/data:/etc/redis/data：映射data目录 redis-server /etc/redis/redis.conf：服务使用指定的配置文件 --name mysql-dev 为容器命名 --privileged=true：赋予容器内的root拥有真正root权限 --requirepass &quot;pwd&quot;：给redis设置密码（如果挂载了外部的配置文件并设置过了，就无需再次设置） --appendonly yes：开启数据持久化（如果挂载了外部的配置文件并设置过了，就无需再次设置）","link":"/2018/10/01/docker-in-action-03/"},{"title":"lombok 实战","text":"其实早就听过lombok，作为java开发者心中奇技淫巧，确实给我们开发带来了很多便捷。很多大牛也写博客对其进行详细的介绍，文章末尾会给出一些文章链接以供学习，而本篇文章记录下本人在接触、使用lombok后的一些心得。 lombok 介绍作为一个java开发者，我们日常开发过程中无法避免类似getter or setter 这样的代码出现在我们的工程中，又或是引用日志的时候无法避免每个文件中都写一遍 1private Logger log = LoggerFactory.getLogger(this.getClass()); 也有人为了解决这个问题，将其封装成一个工具类，让我们可以通过LogUtil.info(&quot;log&quot;)这样进行日志的输出，但是使用过的人也许会发现，一般我们打印的日志，日志会输出日志所在类的路径，但是我们使用LogUtil工具类来帮我们输出的话，日志只输出该工具类的路径（当然可以用反射来输出调用LogUtil类的路径），不方便bug排查。 准备工作使用lombok前需要做两件事： 1、首先是在我们使用的IDE中，安装lombok插件，我这边介绍IDEA的按照过程， 1File &gt; Settings &gt; Plugins &gt; Browse repositories 然后搜索Lombok Plugin ，然后点击右边绿色的install 按钮进行安装，安装后需要重启IDEA。 2、在maven工程中引入lombok.jar 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 接下来就进入激动人心的lombok实战环节。 lombok注解1、@Log or @Slf4j我们不用自己显示获取log对象，不用自己封装工具类去输出日志，一个注解帮我们搞定 123456789// private Logger log = LoggerFactory.getLogger(this.getClass());@Log// @Slf4jpublic class LogTest { public static void main(String[] args) { log.info(\"==&gt; \" + LocalDateTime.now()); }} 2、@Data虽然使用IDE为我们的pojo生成getter、 setter或者toString这些方法对我们来说习以为常，但是在代码中嵌入一堆getter、 setter方法显得不那么优雅，而且我们添加或者修改属性就要重新生成对于的getter、 setter方法，所以这里我们可以使用@Getter，@Setter注解来帮我们做这些事 1234567891011121314151617181920212223242526272829303132333435363738394041@Getter@Setterpublic class LombokPerson { private Integer id; private String name; private String sex;}// 使用idea，jdk1.8 反编译class文件得到如下代码public class LombokPerson { private Integer id; private String name; private String sex; public LombokPerson() { } public Integer getId() { return this.id; } public String getName() { return this.name; } public String getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public void setName(String name) { this.name = name; } public void setSex(String sex) { this.sex = sex; }} 其实我们还可以直接在类上使用@Data注解，它的作用比较全，包含了@ToString，@EqualsAndHashCode，所有字段的@Getter和所有非final字段的@Setter, @RequiredArgsConstructor，所以我们直接使用@Data注解来替换之前的@Getter，@Setter注解 123456@Datapublic class LombokPerson { private Integer id; private String name; private String sex;} 这里除了getter，setter方法外，还会生成equals、canEqual、hashCode、toString，由于代码篇幅较长，这里就不贴出编译后的字节码了，大家可以自行测试 3、@NonNull其实对于NEP（NullPointerException，后文采用简称NPE），java8已经引入了Optional来尝试解决这个问题，但是这并没有强制检查，还是会导致NPE，如果你直接使用get方法去获取Optional中包装的空值。 而lombok提供的@NonNull，是帮我写了非空判断 123456789101112131415161718public class Demo01 { public static void main(String[] args) { String str = null; checkNull(str); } public static void checkNull(@NonNull String msg) { System.out.println(msg.length()); }}// 下面是反编译的class文件public static void checkNull(@NonNull String msg) { if (msg == null) { throw new NullPointerException(\"msg is marked @NonNull but is null\"); } else { System.out.println(msg.length()); }} 可以看到lombok帮我添加了一个if判断，如果为空，就抛一个NPE。不过这里和Optional的设计理念不一样，Optional想从根源上去解决Null这个问题，而lombok的@NonNull只是保证了程序调用对象方法的时候，会对对象是否为空进行检查，如果为空就抛NPE。 那么使用和不使用都是会抛NPE，那么@NonNull 有什么用处呢，其实通过输出的异常堆栈我们就知道，使用 @NonNull使我们能够快速定位到错误出现的地方msg is marked @NonNull but is null 123456// 使用 @NonNullException in thread \"main\" java.lang.NullPointerException: msg is marked @NonNull but is null // 不使用 @NonNullException in thread \"main\" java.lang.NullPointerException 4、@Builder说到生成器模式我们有些同学可能会感到陌生，但是类似下面这样的代码，我们肯定遇到过 1234Request request = new Request.Builder() .post(body) .url(url) .build(); 这是OkHttp构建request对象的api，这种方式来初始化对象并赋值的方式看起来比较优雅，其实我们稍微改造下之前的pojo也能达到类似的链式调用的效果 12345678910// Person对象的set方法public void setId(Integer id) { this.id = id;}// 修改为public Person setId(Integer id) { this.id = id; return this;} 我们可以写个代码来测试下 1234567public static void main(String[] args) { Person person = new Person() .setId(1) .setName(\"laoWang\") .setSex(\"nan\"); System.out.println(person); } 那么使用@Builder呢，我们来测试下 123456789101112131415161718@Builder@ToStringpublic class LombokPerson2 { private Integer id; private String name; private String sex;}// 测试代码public static void main(String[] args) { LombokPerson2 person2 = LombokPerson2 .builder() .id(1) .name(\"laoWang\") .sex(\"男\") .build(); System.out.println(person2);} 是不是很像，其实我们修改的Person还算不上是使用了生成器模式，不过可以帮助理解为什么能做到像这样的链式调用。 目前我日常使用的几个注解已经介绍完毕，当然lombok提供的功能不止这些，如果你有兴趣可以自己搜索或者翻看下面这两篇博客。 Lombok：让JAVA代码更优雅 Java开发神器Lombok的使用与原理","link":"/2018/08/26/lombok/"},{"title":"Java8 Stream实战","text":"参考自《Java 8实战》 什么是stream为什么使用Stream？因为它能让我们更高效地处理集合，让我们可以简洁地表达复杂的数据处理查询。此外，Stream可以透明地并行化。我们可以使用Stream API完成以下操作： 可以表达复杂的数据处理查询 可以使用filter、distinct、skip和limit对流做筛选和切片 可以使用map和flatmap提取或转换流中的元素 可以使用findFirst和findAny方法查找流中的元素 可以使用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词 可以使用reduce方法将流中的所有元素 迭代合并成一个结果 除此之外我们应该知道，流不仅可以 从集合创建，也可以从值、数组、文件以及iterate与generate等特定的方法创建。 stream实践准备工作创建交易员实体类： 1234567891011121314151617181920212223242526public class Trader { private String name; private String city; public Trader(String name, String city) { this.name = name; this.city = city; } public String getName() { return name; } public String getCity() { return city; } @Override public String toString() { return \"Trader{\" + \"name='\" + name + '\\'' + \", city='\" + city + '\\'' + '}'; }} 创建交易记录实体类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction { private Trader trader; private int year; private int value; public Transaction(Trader trader, int year, int value) { this.trader = trader; this.year = year; this.value = value; } public Trader getTrader() { return trader; } public void setTrader(Trader trader) { this.trader = trader; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } @Override public String toString() { return \"Transaction{\" + \"trader=\" + trader + \", year=\" + year + \", value=\" + value + '}'; }} 这里我增加了一个工具类，用于获取测试demo所需的集合： 12345678910111213141516171819public class ListUtil { public static List&lt;Transaction&gt; getList() { Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); return Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); }} 编码1、找到2011年发生的所有交易，并按交易额排序（从低到高） 12345678910111213141516public class Demo01 { public static void main(String[] args) { List&lt;Transaction&gt; collect = ListUtil.getList() .stream() .filter(n -&gt; n.getYear() == 2011) .sorted(Comparator.comparing(Transaction::getValue)) /// 从高到低 //.sorted(Comparator.comparing(Transaction::getValue).reversed()) .collect(Collectors.toList()); collect.forEach(System.out::println); }} 2、交易员都在哪些不同的城市工作过 123456789101112131415public class Demo02 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(n -&gt; n.getTrader().getCity()) .distinct() /// 返回一个List //.collect(Collectors.toList()); .collect(Collectors.joining(\", \")); System.out.println(collect); }} 3、查找所有来自剑桥的交易员并按照姓名排序 123456789101112131415public class Demo03 { public static void main(String[] args) { List&lt;Trader&gt; cambridge = ListUtil.getList() .stream() .map(Transaction::getTrader) .filter(trader -&gt; \"Cambridge\".equals(trader.getCity())) .distinct() .sorted(Comparator.comparing(Trader::getName)) .collect(Collectors.toList()); cambridge.forEach(System.out::println); }} 4、返回所有交易员的姓名字符串，按照字母顺序排序 1234567891011121314public class Demo04 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .sorted(String::compareTo) .collect(Collectors.joining(\", \")); System.out.println(collect); }} 5、有没有交易员是在米兰工作的 12345678910111213141516171819public class Demo05 { public static void main(String[] args) { ListUtil.getList() .stream() .filter(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())) .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .forEach(System.out::println); // 参考 boolean b = ListUtil.getList() .stream() .anyMatch(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())); System.out.println(b); }} 6、打印生活在剑桥的交易员的所有交易额 123456789101112131415161718192021public class Demo06 { public static void main(String[] args) { // 总交易额 int sum = ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .mapToInt(Transaction::getValue) .sum(); System.out.println(\"总交易额: \" + sum); // 参考 ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .map(Transaction::getValue) .forEach(System.out::println); }} 7、所有的交易额中，最高的交易额是多少 12345678910111213141516171819202122232425262728public class Demo07 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue).reversed()) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 OptionalInt reduce = ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max); if (reduce.isPresent()) { System.out.println(reduce.getAsInt()); } // 参考 ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max) .ifPresent(System.out::println); }} 8、找到交易额中最小的交易额 12345678910111213141516171819public class Demo08 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue)) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 ListUtil.getList() .stream() .map(Transaction::getValue) .reduce(Integer::min) .ifPresent(System.out::println); }} 至此，关于stream的8个demo介绍完毕，这只是简单的介绍用法，关于stream还有很多东西值得我们去探索，像stream的筛选和切片、映射、查找和匹配、规约、以及各类收集器（我们甚至可以自定义收集器）。后续我会陆续更新，敬请期待。。。","link":"/2018/08/13/stream-in-action/"}],"tags":[{"name":"annotation","slug":"annotation","link":"/tags/annotation/"},{"name":"java8","slug":"java8","link":"/tags/java8/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"lombok","slug":"lombok","link":"/tags/lombok/"},{"name":"stream","slug":"stream","link":"/tags/stream/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"spring-boot","slug":"spring-boot","link":"/categories/spring-boot/"}]}