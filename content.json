{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"About","text":"作为一个顶天立地的人，你要无怨无悔地走完自己的人生历程。想要怎样才能充实地走完这段历程，这是一个值得思考的问题。是碌碌无为，虚度韶华？还是踏踏实实，拼搏奋斗？这取决于自己。要想成就理想，需要做到不唯众，不唯上。不在意普通的路上是否比别人走得更快，而是又在无人行走的荒野上行走的勇气，这样才能看到别人无法看到的情境。 关于我一枚程序员，这是我对自己现阶段的描述。 虽然文笔一般，但是我还是想写点东西记录些什么，包括学习过程中的一些感悟。 至于写博客，也不算是一时间的心血来潮，很久之前就有过这样的想法，也尝试过很多种方式，最终以现在这种方式呈现出来。 持续更新中… 读书目录 SpringBoot 编程思想 Effective Java Java编程思想 Java8实战 Spring Cloud微服务实战","link":"/about/index.html"}],"posts":[{"title":"自定义注解实战（一）","text":"利用AOP实现注解个人见解：使用aop最大的好处是不侵入业务代码，就可以在方法执行前或者执行后来实现某些功能，比如日志打印，权限处理等等。正是因为不侵入代码的特性，我们不建议利用aop去截断请求（request），返回包含错误信息的响应（response）。其实我之前有这么做过，自定义权限注解，用户没有权限的话，直接返回没有权限的错误信息（response），功能上可以实现，虽然给我抛异常了，有代码洁癖的我就只能使用拦截器的方法实现该注解了，利用拦截器实现注解将在 自定义注解实战（二） 中来介绍，本篇介绍利用aop来实现注解——当说明书来看吧。。。 自定义注解我们先定义一个MyAnno的注解，代码如下： 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface MyAnno { String value();} 其中，@Target(ElementType.METHOD) 定义该注解作用在方法上，使用value()我们在写注解@MyAnno的时候可以直接@MyAnno(&quot;msg&quot;),如果你按照下面的代码来定义注解的话， 123public @interface MyAnno { String param();} 那你使用注解的时候就只能@MyAnno(param = &quot;msg&quot;)了，不管是@MyAnno(&quot;msg&quot;)，还是@MyAnno(param = &quot;msg&quot;)，括号里面都要写value的，如果你定义的注解不需要写的话，那么就在定义的时候加上 default &quot;&quot;;，如下： 123public @interface MyAnno { String param() defaul \"\";} 实现注解按照上面定义完注解其实已经可以使用了，但是没什么功能，如果想让我们自定义的注解work起来，需要利用到Aspectj： 12345678910111213141516171819202122@Aspect@Componentpublic class RealizationMyAnno { @Pointcut(\"@annotation(com.bfh.annotation.MyAnno)\") public void MyMethod(){} @After(\"MyMethod()\") public void doAfterReturning(JoinPoint joinPoint){ System.out.println(\"RealizationMyAnno.doAfterReturning()\"); String targetName = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] params = joinPoint.getArgs(); // 实际开发过程中使用log打印 System.out.println(\"targetName:\" + targetName); System.out.println(\"methodName:\" + methodName); }} 这时候我们可以将我们自定义的注解加在方法上了，当程序执行到该方法时，就会打印一些信息，如果targetName，methodName，你也可以做些其他的事情，比如自动打印日志，自动将日志输出到硬盘上等等。。。 补充：其实利用aop去截断request请求也是可以的（如果必须的话），利用异常来截断请求，然后设置统一异常处理，向前端返回错误信息，不过不推荐用异常来处理业务。。。","link":"/2018/04/05/annotation-in-action-01/"},{"title":"行为参数化","text":"本篇内容摘自《Java8 实战》 前言行为参数化和“策略设计模式”相关，它让你定义算法，并将其封装起来（这里称为“策略”），在运行的时候选择一个算法，如果你现在不太明白这句话的意思，可以紧张兮兮的往下看，我将会通过一系列的例子来展示什么叫做行为参数化，以及这种设计模式的优点。 需求0、准备我们先准备一个苹果的实体类，重写它的toString()方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Apple { /** * 苹果颜色 */ private String color; /** * 苹果重量（单位：克） */ private Integer weight; public Apple(String color, Integer weight) { this.color = color; this.weight = weight; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Integer getWeight() { return weight; } public void setWeight(Integer weight) { this.weight = weight; } @Override public String toString() { return \"Apple{\" + \"color='\" + color + '\\'' + \", weight=\" + weight + '}'; }} 然后准备一个工具类去生成测试代码所需的苹果的集合 1234567891011121314151617public class AppleUtil { public static List&lt;Apple&gt; getApples() { return Arrays.asList( new Apple(\"green\", 100), new Apple(\"green\", 120), new Apple(\"red\", 130), new Apple(\"green\", 140), new Apple(\"red\", 150), new Apple(\"green\", 160), new Apple(\"green\", 170), new Apple(\"red\", 180), new Apple(\"green\", 190), new Apple(\"red\", 200), new Apple(\"green\", 210) ); }} 至此，准备工作完成。 1、筛选绿苹果首先，我们需要从一堆苹果中筛选出绿色的苹果 12345678910111213141516171819202122public class Demo1 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterGreenApples(AppleUtil.getApples()); for (Apple apple : apples) { System.out.println(apple); } } /** * 获取绿色的苹果 * @param inventory 未筛选的苹果集合 * @return 绿色苹果的集合 */ public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"green\".equals(apple.getColor())) { result.add(apple); } } return result; }} 这很简单，我们定义了一个filterGreenApples方法，参数为List&lt;Apple&gt;，然后在方法体内遍历这个List，如果苹果是绿色的，就把这个苹果放到新的List&lt;Apple&gt;中，遍历完成后返回新的List&lt;Apple&gt;。 2、筛选红苹果有了筛选绿苹果的经历 ，我们微微一笑，将之前封装的filterGreenApples复制一份，然后改名为filterRedApples,然后修改if代码块中的代码修改为&quot;red&quot;.equals(apple.getColor()),其完整代码如下 123456789public static List&lt;Apple&gt; filterRedApples(List&lt;Apple&gt; inventory) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (\"red\".equals(apple.getColor())) { result.add(apple); } } return result; } 看上去我们“完美”的完成了任务，准备提交代码的时候，又来了一个需求，筛选一半红一半绿的苹果，这时候我们就不太想复制之前的代码了，何不将颜色作为参数传入方法中呢，说干就干 123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, String color) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (color.equals(apple.getColor())) { result.add(apple); } } return result; } 但是这里又暴露出其他问题了，比如，我要筛选出出重量大于150g的苹果，我要筛选出出重量大于150g的红苹果，那我们现有的架构也没法实现这个需求，而且封装的方法会越来越庞大，我们下面将介绍如何去解决这些我呢提。 3、代码重构首先我们写一个接口ApplePredicate 12345@FunctionalInterfacepublic interface ApplePredicate { boolean test(Apple apple);} 我们先不管这个注解，然后再写两个实现类，AppleGreenColorPredicate，AppleHeavyWeightPredicate 123456public class AppleGreenColorPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); }} 123456public class AppleHeavyWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() &gt; 150; }} 然后我们可以封装这样一个方法 123456789public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; } 测试代码 1234567public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } 具体的代码逻辑直接在ApplePredicate的实现类中实现就可以了，将具体的行为当作参数传入到方法中，这就是行为参数化。","link":"/2018/08/11/behavioral-parameterization/"},{"title":"自定义注解实战（二）","text":"利用拦截器实现注解上一篇 自定义注解实战（一） 中说到使用aop最大的好处是不侵入业务代码，但是有些业务需要拦截请求，比如参数校验，为空的话直接返回isNull的错误信息，这时候用AOP来做这件事就显得不太优雅了，所以我想到了用拦截器来实现，定义注解的方式还是一样，这里就不多加赘述了。 声明拦截器声明拦截器我们利用SpringMVC进行配置，而在mvc:interceptors标签下声明interceptor主要有两种方式： 直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。 因为利用拦截器去实现注解的话，要拦截所有请求，所以这里我们直接使用第一种方法，直接定义一个Interceptor实现类的bean对象： 123&lt;mvc:interceptors&gt; &lt;bean class=\"com.bfh.interceptor.MyAnnoInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 实现注解然后就是实现MyAnnoInterceptor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyAnnoInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.setHeader(\"Content-type\", \"application/json;charset=utf-8\"); try { if (handler instanceof HandlerMethod) { HandlerMethod method = (HandlerMethod) handler; MyAnno annotationParams = method.getMethodAnnotation(MyAnno.class); /** * 你定义的校验规则,如果通过校验，直接return true; */ } PrintWriter out = null; try { out = response.getWriter(); out.print(\"你想输出的错误信息...\"); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { if (out != null) { out.close(); } } return false; } catch (Exception e) { e.printStackTrace(); } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, org.springframework.web.servlet.ModelAndView arg3) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response,Object arg2, Exception arg3) throws Exception { }} 这样我们自定义的注解就可以使用了，至于return true还是return false，这个就看你的实际业务需求了。","link":"/2018/04/06/annotation-in-action-02/"},{"title":"构建Spring Boot Starter(一)","text":"Spring Boot Starter初印象初识Spring Boot 时，被其简化Spring应用初始搭建以及开发过程所惊艳到，基于约定优于配置的原则，我们无需从老项目中拷贝大量的xml文件来构建项目，只需利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 就能轻松启动一个Spring应用，极为便捷。 除此之外，以前在没有使用Spring Boot的时候，引入第三方jar包——如引入Mybatis的时候，我们需要在pom文件中引入多个依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;&lt;/dependency&gt; 这无疑给我们做第三方集成的时候增加了难度，也相应增加了依赖管理的难度，如果使用Spring Boot，我们只需引入一个依赖就ok： 1234&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 这是因为 mybatis-spring-boot-starter 其本身可以理解为一个库的集合，帮我们管理了spring整合mybatis所需的依赖。 Spring Boot Starter帮我们处理了Spring应用中各种库之间复杂的依赖关系，但是这不是本篇博客介绍的重点。我们这里计划实现一个自动配置的 starter ，类似启用Eureka的自动注册功能，只需在工程启动类上面加上 @EnableEurekaClient 便可开启服务注册发现功能（需要引入相关依赖），极为方便。 准备工作首先我们要了解Spring官方推荐的命名规范，其中官方starter命名： spring-boot-starter-[name] ，非官方命名： [name]-spring-boot-starter ，所以这里我们给工具starter命名为 build-spring-boot-starter 。 然后我们利用IDEA提供的Spring Initializr 或者通过 https://start.spring.io/ 构建一个spring boot项目，然后引入开发Spring Boot Starter核心依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt; 然后我们准备两个Serivice 用于自动配置，写的简单些，一个将字符串转为大写，一个求两个int型的最大值，都是用了现成的方法，如下： IntegerService： 12345678910public class IntegerService { /** * 取两个int的最大值 */ public int max(int i1, int i2) { return Integer.max(i1, i2); }} StringService: 1234567891011121314public class StringService { /** * 将字符串转为大写 */ public String toUpperCase(String str) { if (StringUtils.isEmpty(str)) { return null; } else { return str.toUpperCase(); } }} 然后准备两个配置类： 123456public class IntegerServiceConfig { @Bean IntegerService integerService() { return new IntegerService(); }} 123456public class StringServiceConfig { @Bean StringService stringService() { return new StringService(); }} 然后让其自动配置，这里提供两种方式： 在resources/META-INF/下创建spring.factories文件，配置如下： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.github.baifenghe.configuration.IntegerServiceConfig 因为Spring Boot在启动的时候会扫描项目所依赖的JAR包，寻找其中spring.factories文件，然后根据其配置来加载配置类。 上述方法只要工程依赖该 starter 后便自动注入所有配置过的Bean，但是我们有时候并不想这样，可能有时候我们只需要使用一个功能，但是却将 starter 里面不需要的Bean也都注入进来，所以我们想通过一个注解来自定义开启某些功能，而不是全部开启，这时候我们可以利用 @Import 注解来实现上诉功能： 首先我们创建一个注解，EnableStringService 123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({StringServiceConfig.class})public @interface EnableStringService {} 用 @Import 来发现配置类从而注入，很类似之前将多个配置文件导入一个主配置文件中一样。 接下来我们来测试刚刚写好的starter ，首先利用 mvn install 将刚刚开发好的 starter 安装到本地，然后新建一个 spring boot 工程引入本依赖， 1234567891011&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.baifenghe&lt;/groupId&gt; &lt;artifactId&gt;build-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后我们写一个Controller来测试我们写的starter，如下： 12345678910111213141516171819202122232425262728@RestControllerpublic class DemoController { @Autowired private IntegerService integerService; @Autowired private StringService stringService; /** * 测试StringService */ @PostMapping(\"testStringService\") public String testStringService(String str) { return stringService.toUpperCase(str); } /** * 测试IntegerService */ @PostMapping(\"testIntegerService\") public int testIntegerService(int n1, int n2) { return integerService.max(n1, n2); }} 在主类上引用 @EnableStringService 注解，开启 StringService（IntegerService 自动注入了） 。 相关代码详见：build-spring-boot 最后的最后，欢迎 watch star fork toolkit-spring-boot-project ，一个好用的，开箱即用的工具集。","link":"/2019/01/08/build-spring-boot-starter-01/"},{"title":"Docker(一)：hello-docker","text":"docker概述Docker是一个开发，运输和运行应用程序的开放平台。Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。 准备工作之前就打算在虚拟机安装centos来好好熟悉下linux，不过事情比较多，一直都没有去做。这次刚好打算了解一波docker，所以就把之前丢掉的linux捡起来。 首先我们准备一个centos环境，这里我安装的是CentOS-7-x86_64-Everything-1804，安装好后打算用终端模拟软件去连接，方便操作。在记忆中搜索片刻，敲下了ifconfig，不过好像我安装的这个版本没有给我安装ifconfig等命令，百度一看说是过时了，那找解决办法吧，ip addr，但是没看见熟悉的xxx.xxx.xxx.xxx，额，又去百度一看，需要我们配置网卡。 那就配置吧，按照百度来的教程，vi /etc/sysconfig/network-scripts/ifcfg-xxx，其实这个命令最后的xxx，就是我们敲ip addr后显示的2：后面的数值，1：一般是lo：，打开后将最后一个ONBOOT=no修改为ONBOOT=yes，这样便能启动网卡，然后我们重启网络服务service network restart，再敲ip addr就能看见IP地址了。 docker安装首先 运行命令yum install docker安装docker，然后我们通过docker version来查看docker是否安装成功 12345[root@localhost ~]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: 这里能看到我们安装的版本是1.13.1。然后我们启动docker服务，将其设置为 开机启动 12service docker startchkconfig docker on 修改docker镜像仓库就像使用maven要修改镜像仓库那样，使用docker也不例外，我们可以将其修改为docker中国官方提供的registry.docker-cn.com来访问，其中包含了主流的docker镜像，通过修改/etc/docker/daemon.json文件，添加如下配置，如果是第一次安装docker，该文件中只是{}，替换如下内容即可。 1234{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;live-restore&quot;: true} hello world像我们学习编程语言的时候，第一个例子便是输出一行hello world，不过docker提供有docker版的hello world 供我们下载使用，我们通过docker pull去获取它。 123456Using default tag: latestTrying to pull repository docker.io/library/hello-world ... latest: Pulling from docker.io/library/hello-world9db2ca6ccae0: Pull complete Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for docker.io/hello-world:latest 我们可以通过docker image ls去查看我们本地安装有哪些镜像 12REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/hello-world latest 2cb0d9787c4d 6 weeks ago 1.85 kB 证明镜像下载到本地后，我们通过docker run docker.io/hello-world 来运行这个镜像 1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 输出这段提示后，hello-world便自动终止了（像mysql，redis这些提供服务的镜像是不会自动终止）。 docker常用命令123456# 启动service docker start# 重启service docker restar# 停止service docker stop 参考 docker docs Docker(一)：Docker入门教程 周立–Docker系列教程","link":"/2018/09/02/docker-in-action-01/"},{"title":"Docker(二)：部署springboot项目","text":"Dockerfile概述Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Docker可以通过读取来自 Dockerfile的指令自动构建镜像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用、组合容器的所有命令。使用docker build 可以构建连续执行的多个指令集。 接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以docker部署springboot项目为例。 准备springboot项目首先我们通过spring initializr来构建一个springboot工程，只添加了一个HelloController，代码如下： 1234567@RestControllerpublic class HelloDockerController { @RequestMapping(\"/hello\") public String hello() { return \"hello, \" + LocalDateTime.now(); }} 可以使用docker构建插件来构建镜像，可以查考纯洁的微笑的博客来构建，这里我们直接将springboot工程打成jar包，来构建docker镜像。 首先将之前构建的springboot工程打包，这样我们就得到了一个hello-docker-0.0.1-SNAPSHOT.jar,然后我们再准备一个Dockerfile，内容如下 1234FROM java:8VOLUME /tmpADD hello-docker-0.0.1-SNAPSHOT.jar hello-docker.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/hello-docker.jar&quot;] 其中 FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 构建镜像 1docker build -t image-name . 然后我们通过docker images就能看见我们制作的docker镜像 12345REPOSITORY TAG IMAGE ID CREATED SIZEhello-docker latest 417dca81c225 8 minutes ago 672 MBdocker.io/mysql 5.7 563a026a1511 2 weeks ago 372 MBdocker.io/nginx latest c82521676580 2 months ago 109 MBdocker.io/java 8 d23bdf5b1b1b 20 months ago 643 MB 这样我们可以启动该镜像 1docker run -p 8080:8080 -t hello-docker 如果出现了端口映射错误，可以暂时关闭防火墙systemctl stop firewalld.service，然后重启docker服务service docker restart，重新启动镜像即可。 通过docker ps可以查看正在运行的项目 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScaa44939f959 hello-docker &quot;java -Djava.secur...&quot; 14 seconds ago Up 13 seconds 0.0.0.0:8080-&gt;8080/tcp trusting_brattainf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 7 days ago Up 2 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 然后通过访问http://your-ip:8080/hello，返回 1hello, 2018-09-25T13:38:53.246 即部署成功。 参考 docker docs Docker(二)：Dockerfile 使用介绍","link":"/2018/09/26/docker-in-action-02/"},{"title":"构建Spring Boot Starter(二)","text":"注：案例工程使用的spring boot 版本为 2.1.2.RELEASE，Java 版本为 1.8 熟悉spring boot的人肯定对 application.yml 或者 application.properties 配置文件很眼熟（因为个人喜好yaml方式，所以以下示例选用application.yml），因为spring boot 有着约定大于配置的特性，所以当其默认的配置不是我们需要的时候，就可以在工程的resource 目录下找到application.yml 进行相关配置，然后启动程序，这时spring boot便会按照新的配置去运行。 例如 springboot 默认启动端口时8080，如果我们的机器8080端口已被使用，那么就要配置一个未被使用的端口，这是我们只要在application.yml 中填写如下配置： 12server: port: 18080 然后启动程序…… 1[ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 18080 (http) with context path &apos;&apos; 通过控制台日志我们可以发现，此时spring boot程序的端口已被修改为18080。 这种开发方式在spring boot中随处可见，比如如上所示的设置端口，或者如下所示的开启spring-cloud-gateway 通过注册中心自动创建路由，只需要进行如下配置即可： 123456spring: cloud: gateway: discovery: locator: enabled: true 而我们也可以模仿这种开发方式，让我们的程序更加灵活。所以本篇博客将讲述如何在 springboot 2.x 中读取配置文件。 读取application.yml1. @Value在spring boot 2.x中，如果我们需要读取配置文件，如下面这种形式的配置， 12bfh: name: BFH 可以通过 @Value 注解来实现，如下： 1234567@Value(\"${bfh.name}\")private String name;@GetMapping(\"getValueOfName\")public String getValueOfName() { return name;} 获取配置：curl -X GET &quot;http://127.0.0.1:18080/getValueOfName 2. @ConfigurationProperties@Value 注解虽然好用，但是不支持集合，IDEA 也不能做到智能提示，不管是造轮子，还是平时项目开发都建议使用 @ConfigurationProperties 注解，这样较为规范，接下来将介绍如何使用。 123456789@Data@Component@ConfigurationProperties(prefix = \"bfh\")public class DemoProperties { private String name = \"bfh\"; private Set&lt;String&gt; ips = new LinkedHashSet&lt;&gt;();} 注：其中属性名要对应配置文件中的属性，比如这里面的name属性，对应配置文件中的bfh.name 如果除去注解不看的话，那么这只是一个普通的简单Java类，首先我们使用 @ConfigurationProperties(prefix = &quot;bfh&quot;) 来读取 application.yml 中前缀为 bfh 的配置，使用lombok 的 @Data 来提供必要的 getter setter 方法，最后使用 @Component 将其注入 spring 容器。 我们在 application.yml 添加一些配置数据： 12345678bfh: name: BFH ips: - 127.0.0.1 - 127.0.0.2 - 127.0.0.3 - 127.0.0.4 - 127.0.0.5 在我们需要读取配置文件的地方注入之前编写好的 DemoProperties 通过相应的get方法就能获取到配置信息： 123456789101112@Autowiredprivate DemoProperties properties;@GetMapping(\"getStarterIps\")public Set&lt;String&gt; getStarterIps() { return properties.getIps();}@GetMapping(\"getStarterName\")public String getStarterName() { return properties.getName();} 读取自定义yml配置文件首先我们创建一个 YamlPropertyLoaderFactory ，代码如下： 123456789101112public class YamlPropertyLoaderFactory extends DefaultPropertySourceFactory {@Overridepublic PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { if (resource == null) { super.createPropertySource(name, resource); } return new YamlPropertySourceLoader().load(resource.getResource().getFilename(), resource.getResource()).get(0); }} 然后我们准备一个 CommonProperties ，和读取 application.yml不同的是，读取自定义的yml文件，我们需要增加一个注解来指定一下读取的配置文件位置信息，@PropertySource(value = &quot;classpath:common.yml&quot;, factory = YamlPropertyLoaderFactory.class) ，代码如下： 12345678910@Data@Component@PropertySource(value = \"classpath:common.yml\", factory = YamlPropertyLoaderFactory.class)@ConfigurationProperties(prefix = \"common\")public class CommonProperties { private String name = \"common\"; private Set&lt;String&gt; list = new LinkedHashSet&lt;&gt;();} 获取配置信息的方式如下： 123456789101112@Autowiredprivate CommonProperties commonProperties;@GetMapping(\"getCommonList\")public Set&lt;String&gt; getCommonList() { return commonProperties.getList();}@GetMapping(\"getCommonName\")public String getCommonName() { return commonProperties.getName();} 相关案例代码移步 blog-samples 。 欢迎 watch star fork toolkit-spring-boot-project ，一个好用的，开箱即用的工具集。","link":"/2019/02/15/build-spring-boot-starter-02/"},{"title":"Docker(三)：使用docker启动mysql & redis","text":"Docker 很便捷，最开始有这种感受是用一行命令去启动了 MySQL服务。想当初刚接触数据库那会，那么费力气的安装MySQL也是服气。（捂脸哭~ 但是在启动MySQL容器之前，我们需要做些准备工作，这是因为数据库本身的特殊性，我们需要将容器的数据映射到主机的目录中，这样就不担心手滑将容器删除导致数据丢失了。 准备工作首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 1mkdir -p /opt/docker/mysql/{conf,data} 然后创建MySQL的配置文件 1vi /opt/docker/mysql/conf/my.conf 添加如下配置 12345678[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 准备好我们便可以创建容器。 创建 MySQL创建容器（就是这行命令从零启动了MySQL服务） 1docker run -d -p 3306:3306 --privileged=true -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf -v /opt/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-dev mysql:5.7 补充说明： -p 3306:3306 将容器的 3306 端口映射到主机的 3306 端口，宿主机:容器 -v /opt/docker/mysql/conf/my.cnf:/etc/mysql/my.conf 将主机/opt/docker/mysql/conf/my.conf挂载到容器的 /etc/mysql/my.cnf -v /opt/docker/mysql/data:/var/lib/mysql 将主机/opt/docker/mysql/data挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 初始化 root 用户的密码 --name mysql-dev 为容器命名 然后通过docker ps命令就可以查看正在运行的docker服务 123[root@localhost /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 9 days ago Up 26 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 用你喜欢的数据库可视化工具去连接MySQL服务，successful !!! 创建 Redis如果我们本地没有镜像，在启动Redis服务的时候，会自动尝试pull，所以我们可以通过一行命令就能启动Redis服务。如果通过第二种方式启动的话，需要提前准备Redis的配置文件 首先我们准备以下目录，你也可以选择其他目录，到时候修改下命令中的挂载目录位置即可。 1mkdir -p /opt/docker/redis/{conf,data} 然后去下载一个对应版本的 redis.conf ，放到下面目录中 1/opt/docker/redis/conf/redis.conf 然后需要修改以下几点： 注释bind 127.0.0.1 注释掉daemonize yes ，或者设置为：daemonize no 如果要设置密码：requirepass your-password 设置数据持久化：appendonly yes 下面提供了两种方式启动 Redis 12345# 启动一个Redis服务docker run -d -p 6379:6379 --name redis-dev redis:4.0# 启动redis并挂载外部conf，需自己去官网下载redis.confdocker run -d -p 6379:6379 -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /opt/docker/redis/data:/etc/redis/data --name redis-dev redis:4.0 redis-server /etc/redis/redis.conf 然后通过docker ps查看处于活跃状态的docker服务 123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c5ed64050de redis:4.0 &quot;docker-entrypoint...&quot; 3 minutes ago Up 3 minutes 0.0.0.0:6379-&gt;6379/tcp redis-devf80f9ed36b71 mysql:5.7 &quot;docker-entrypoint...&quot; 13 days ago Up 24 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-dev 补充说明： 一般使用Redis会做高可用，设置密码，挂载外部的data以及conf，做数据持久化，以下是对上述命令做一些解释以及补充， -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf：挂载配置文件 -v /opt/docker/redis/data:/etc/redis/data：映射data目录 redis-server /etc/redis/redis.conf：服务使用指定的配置文件 --name mysql-dev ：为容器命名 --privileged=true：赋予容器内的root拥有真正root权限 --requirepass &quot;pwd&quot;：给Redis设置密码（如果挂载了外部的配置文件并设置过了，就无需再次设置） --appendonly yes：开启数据持久化（如果挂载了外部的配置文件并设置过了，就无需再次设置）","link":"/2018/10/01/docker-in-action-03/"},{"title":"Java8 lambda 实战","text":"本篇内容摘自《Java8 实战》 在阅读本篇文章之前，我希望你能了解什么是行为参数化——它允许你定义一个代码块来表示一个行为，然后传递它，利用这个概念，你就可以编写更为灵活且可重复使用的代码。 在行为参数化那篇博客中，我们最后写出了这样的代码 123456789101112131415161718192021public class Demo4 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByPredicate(AppleUtil.getApples(), new AppleGreenColorPredicate()); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByPredicate(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这里有一个问题，我们要筛选绿色苹果的时候编写了一个类AppleGreenColorPredicate去实现ApplePredicate接口，但是有时候这个方法可能只会使用一次，如果这时候还要按照上面的方法去做的话，就显得有些不太合适。那么我们要如何去做呢？这时候我们想到了一个匿名内部类，代码如下 12345678910111213141516171819202122232425262728public class Demo5 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), new ApplePredicate() { @Override public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); } }); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 这样我们就可以不用创建一个实现类去实现ApplePredicate接口，但是匿名内部类不太友好，它占用了很多空间，让我们的代码显得很笨重与啰嗦，让代码显得不那么易读。那有没有办法去解决这个问题呢，答案是有的，在java8中，我们可以使用lambda表达式 去改造之前的代码，如下 1234567891011121314151617181920212223public class Demo6 { public static void main(String[] args) { List&lt;Apple&gt; apples = filterApplesByColor(AppleUtil.getApples(), apple -&gt; \"green\".equals(apple.getColor())); for (Apple apple : apples) { System.out.println(apple); } } public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, ApplePredicate predicate) { List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) { if (predicate.test(apple)) { result.add(apple); } } return result; }} 我想你应该发现了，之前匿名内部类的地方被这样一句代码代替了——apple -&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的左边是参数列表，apple是简写，我们可以写成这样——(Apple apple)-&gt; &quot;green&quot;.equals(apple.getColor())，在-&gt;的右边是函数主体，这样写让我们的代码变得简洁很多。之所以我们能使用lambda表达式是依赖于类型推断，这是由编译器通过上下文环境推断而出。 比如我们要对苹果的重量从大到小进行排序 12345public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight)); apples.forEach(System.out::println); } 当苹果的重量一样，我们按照苹果的颜色来排序也是可以做到的，如下 1234567public class Demo7 { public static void main(String[] args) { List&lt;Apple&gt; apples = AppleUtil.getApples(); apples.sort(Comparator.comparing(Apple::getWeight).thenComparing(Apple::getColor)); apples.forEach(System.out::println); }} 未完待续。。。","link":"/2018/08/12/java8-lambda/"},{"title":"MapStruct 实战","text":"前言MapStruct 是一个Java 注解处理器 ，用于生成类型安全的bean映射类。 我们需要做的就是定义一个映射接口，声明映射方法。在编译期间，MapStruct 将生成此接口的实现类。此实现使用简单的 Java 方法调用（getter setter…）在源对象和目标对象之间进行属性映射，没有使用反射或类似的内容。 与手动编写属性映射代码相比，MapStruct 通过生成冗长且易于出错的代码来节省时间。按照约定优于配置，MapStruct 使用合理的默认值（用户没有自定义配置或实现特殊行为）。 与动态映射框架相比，MapStruct 具有以下优点： 通过使用普通方法调用而不是反射来快速执行 编译时类型安全性：只能映射彼此映射的对象和属性（不能将订单实体意外映射到客户DTO等）。 编译期错误报告： 映射不完整（并非所有目标属性都被映射） 映射不正确（找不到正确的映射方法或类型转换） 引入依赖项目使用 Maven 构建，其他方式如 Gradle，Ant 等请查考官网 设置 12345678910111213141516171819...&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.1.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;... 基本使用基本映射要创建映射器，只需定义一个 Java 接口，并使用 org.mapstruct.Mapper 注解： 12345678@Mapperpublic interface StudentMapper { StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class); @Mapping(source = \"staffName\", target = \"studentName\") Student toStudent(Staff staff);} 该 @Mapper 注解将使用 MapStruct 的代码生成器创建 StudentMapper 接口的实现 StudentMapperImpl，在生成的方法实现中，源类型（例如Staff）的所有可读属性都将被复制到目标类型（例如Student）的相应属性中： 当一个属性与其目标实体对应的名称相同时，它将被隐式映射。 当属性在目标实体中具有不同的名称时，可以通过@Mapping 注解指定其名称。 StudentMapperImpl.class 反编译如下： 1234567891011121314public class StudentMapperImpl implements StudentMapper { public StudentMapperImpl() { } public Student toStudent(Staff staff) { if (staff == null) { return null; } else { Student student = new Student(); student.setStudentName(staff.getStaffName()); return student; } }} 单元测试如下： 123456@Testpublic void test1() { Staff staff = PojoUtil.getStaffInstance(); Student student = StudentMapper.INSTANCE.toStudent(staff); assert Objects.equals(staff.getStaffName(), student.getStudentName());} 多源参数映射多源参数映射即多对一映射，使用 @Mapping(source = &quot;student.studentName&quot;, target = &quot;name&quot;) 可以将 student 的 studentName 属性 映射（复制）到 Person 的 name 上，代码如下： 1234567@Mapperpublic interface PersonMapper { @Mapping(source = \"student.studentName\", target = \"name\") @Mapping(source = \"staff.staffNo\", target = \"personNo\") Person toPerson(Student student, Staff staff);} 更新现有Bean在某些情况下，不需要创建目标类型的新实例，而是更新该类型的现有实例。可以通过为目标对象添加一个参数并将其标记为 @MappingTarget， 其中，person1的同名属性会完全覆盖（更新）person2的同名属性，如下 123456@Mapperpublic interface PersonMapper { void update(Person person1, @MappingTarget Person person2);} 使用依赖注入这里使用 Spring 容器来介绍 MapStruct 如何使用依赖注入，我们需要通过 Mapper#componentModel 来指定DI 类型，目前支持 default：映射器不使用组件模型，实例通常通过Mappers.getmapper（类）获取。 cdi：生成的映射器是应用程序范围的cdi bean，可以通过@Inject 获取。 spring：生成的映射器是一个spring bean，可以通过@Autowired 获取。 jsr330：生成的映射器用`@javax.inject.named和@singleton注释，可以通过@inject` 获取。 实例代码如下： 1234@Mapper(componentModel = \"spring\")public interface PersonMapper { ...} 调用其他映射器虽然我们可以通过 @Mapping 注解来灵活的映射不同实体的属性对应关系，但是遇到日期类型格式化为字符串类型，我们不得不复制粘贴例如 @Mapping(target = &quot;registryDate&quot;, dateFormat = &quot;dd.MM.yyyy&quot;) 这样的映射关系，有没有什么更为简单通用的实现呢，MapStruct 提供了 Mapper#uses ，我们可以自定义一些高级映射，例如 DateMapper，代码如下： 123456789101112131415161718192021@Componentpublic class DateMapper { public String asString(Date date) { return date != null ? new SimpleDateFormat(\"yyyy-MM-dd\").format(date) : null; } public Date asDate(String date) { try { return date != null ? new SimpleDateFormat(\"yyyy-MM-dd\").parse(date) : null; } catch (ParseException e) { throw new RuntimeException(e); } }}// 指定 DateMapper@Mapper(componentModel = \"spring\", uses = DateMapper.class)public interface PersonMapper { ...} 这样就能将 Date registryDate 通过自定义的转换方式转化为 String registryDate。 补充说明这里补充一些 Mapping的其他用法： 忽略映射字段： @Mapping(target = &quot;gender&quot;, ignore = true) 日期格式化： @Mapping(target = &quot;registryDate&quot;, dateFormat = &quot;dd.MM.yyyy&quot;) 数值格式化： @Mapping(source = &quot;price&quot;, numberFormat = &quot;$#.00&quot;) 表达式映射： @Mapping(target = &quot;timeAndFormat&quot;, expression = &quot;java(new org.sample.TimeAndFormat( s.getTime(), s.getFormat()) 默认表达式： @Mapping(target=&quot;id&quot;, source=&quot;sourceId&quot;, defaultExpression = &quot;java( UUID.randomUUID().toString() )&quot;) … 其他用法，如有兴趣，可移步 官方文档 。 参考文档 mapstruct 官方文档","link":"/2019/10/19/map-struct-in-action/"},{"title":"MinIO 实战","text":"MinIO 快速入门MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。 MinIO是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL。 安装 MinIO我们直接使用 Docker 来安装 MinIO ，这里使用的是稳定版： 1docker run -d -p 9000:9000 --name minio-dev -e \"MINIO_ACCESS_KEY=admin\" -e \"MINIO_SECRET_KEY=admin\" -v /apps/minio/data:/data -v /apps/minio/conf:/root/.minio minio/minio server /data 安装 MinIO ClientMinIO Client (mc) 为ls，cat，cp，mirror，diff，find等UNIX命令提供了一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。 1234567891011121314151617ls 列出文件和文件夹。mb 创建一个存储桶或一个文件夹。cat 显示文件和对象内容。pipe 将一个STDIN重定向到一个对象或者文件或者STDOUT。share 生成用于共享的URL。cp 拷贝文件和对象。mirror 给存储桶和文件夹做镜像。find 基于参数查找文件。diff 对两个文件夹或者存储桶比较差异。rm 删除文件和对象。events 管理对象通知。watch 监听文件和对象的事件。policy 管理访问策略。session 为cp命令管理保存的会话。config 管理mc配置文件。update 检查软件更新。version 输出版本信息。 首先需下载 MinIO Client ，这里同样使用Docker 来进行操作： 123docker pull minio/mcdocker run minio/mc ls playdocker run -it --entrypoint=/bin/sh minio/mc 添加云存储服务1mc config host add &lt;ALIAS&gt; &lt;YOUR-S3-ENDPOINT&gt; &lt;YOUR-ACCESS-KEY&gt; &lt;YOUR-SECRET-KEY&gt; &lt;API-SIGNATURE&gt; 别名就是给你的云存储服务起了一个短点的外号。S3 endpoint,access key和secret key是你的云存储服务提供的。API签名是可选参数，默认情况下，它被设置为”S3v4”。 示例-MinIO云存储1mc config host add minio http://127.0.0.1:9000 admin admin S3v4 首先我们创建一个 bucket 1mc mb minio/public # 创建桶 然后将其桶策略设置为开放管理，以便于我们通过url 直接访问资源： 1mc policy set public minio/public 测试我们可以使用浏览器访问 http://127.0.0.1:9000 进行登陆操作，进入 public 目录下上传一张图片 test.jpg ，访问 http://127.0.0.1:9000/public/test.jpg ，图片能正常显示。 实战下面将介绍 MinIO Java Client API ，首先我们引入 Maven 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;3.0.10&lt;/version&gt;&lt;/dependency&gt; 然后创建一个 FileController 123456789101112131415161718192021222324252627@RestControllerpublic class FileController { public static final String OSS_PATH = \"http://byference.com:9000\"; @PostMapping(\"fileUpload\") public String fileUpload(MultipartFile file) throws Exception { String bucketName = \"public\"; MinioClient minioClient = new MinioClient(OSS_PATH); if (!minioClient.bucketExists(bucketName)) { minioClient.makeBucket(bucketName); } String objectName = generateFileName(file.getOriginalFilename()); minioClient.putObject(bucketName, objectName, file.getInputStream(), file.getContentType()); return String.format(\"%s/public/%s\", OSS_PATH, objectName); } /** * generateFileName */ public String generateFileName(String fileName) { return UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"_\" + fileName; }} 然后使用 PostMan 进行测试","link":"/2019/10/27/minio-in-action/"},{"title":"lombok 实战","text":"其实早就听过lombok，作为java开发者心中奇技淫巧，确实给我们开发带来了很多便捷。很多大牛也写博客对其进行详细的介绍，文章末尾会给出一些文章链接以供学习，而本篇文章记录下本人在接触、使用lombok后的一些心得。 lombok 介绍作为一个java开发者，我们日常开发过程中无法避免类似getter or setter 这样的代码出现在我们的工程中，又或是引用日志的时候无法避免每个文件中都写一遍 1private Logger log = LoggerFactory.getLogger(this.getClass()); 也有人为了解决这个问题，将其封装成一个工具类，让我们可以通过LogUtil.info(&quot;log&quot;)这样进行日志的输出，但是使用过的人也许会发现，一般我们打印的日志，日志会输出日志所在类的路径，但是我们使用LogUtil工具类来帮我们输出的话，日志只输出该工具类的路径（当然可以用反射来输出调用LogUtil类的路径），不方便bug排查。 准备工作使用lombok前需要做两件事： 1、首先是在我们使用的IDE中，安装lombok插件，我这边介绍IDEA的按照过程， 1File &gt; Settings &gt; Plugins &gt; Browse repositories 然后搜索Lombok Plugin ，然后点击右边绿色的install 按钮进行安装，安装后需要重启IDEA。 2、在maven工程中引入lombo 的依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 接下来就进入激动人心的lombok实战环节。 lombok注解1、@Slf4j我们不用自己显示获取log对象，不用自己封装工具类去输出日志，一个注解帮我们搞定 12345678// private Logger log = LoggerFactory.getLogger(this.getClass());@Slf4jpublic class LogTest { public static void main(String[] args) { log.info(\"==&gt; \" + LocalDateTime.now()); }} 2、@Data虽然使用IDE为我们的pojo生成getter、 setter或者toString这些方法对我们来说习以为常，但是在代码中嵌入一堆getter、 setter方法显得不那么优雅，而且我们添加或者修改属性就要重新生成对于的getter、 setter方法，所以这里我们可以使用@Getter，@Setter注解来帮我们做这些事 1234567891011121314151617181920212223242526272829303132333435363738394041@Getter@Setterpublic class LombokPerson { private Integer id; private String name; private String sex;}// 使用idea，jdk1.8 反编译class文件得到如下代码public class LombokPerson { private Integer id; private String name; private String sex; public LombokPerson() { } public Integer getId() { return this.id; } public String getName() { return this.name; } public String getSex() { return this.sex; } public void setId(Integer id) { this.id = id; } public void setName(String name) { this.name = name; } public void setSex(String sex) { this.sex = sex; }} 其实我们还可以直接在类上使用@Data注解，它的作用比较全，包含了@ToString，@EqualsAndHashCode，所有字段的@Getter和所有非final字段的@Setter, @RequiredArgsConstructor，所以我们直接使用@Data注解来替换之前的@Getter，@Setter注解 123456@Datapublic class LombokPerson { private Integer id; private String name; private String sex;} 这里除了getter，setter方法外，还会生成equals、canEqual、hashCode、toString，由于代码篇幅较长，这里就不贴出编译后的字节码了，大家可以自行测试 3、@NonNull其实对于NEP（NullPointerException，后文采用简称NPE），java8已经引入了Optional来尝试解决这个问题，但是这并没有强制检查，使用不当还是会导致NPE，如果你直接使用get方法去获取Optional中包装的空值。 而lombok提供的@NonNull，是帮我写了非空判断 123456789101112131415161718public class Demo01 { public static void main(String[] args) { String str = null; checkNull(str); } public static void checkNull(@NonNull String msg) { System.out.println(msg.length()); }}// 下面是反编译的class文件public static void checkNull(@NonNull String msg) { if (msg == null) { throw new NullPointerException(\"msg is marked @NonNull but is null\"); } else { System.out.println(msg.length()); }} 可以看到lombok帮我添加了一个if判断，如果为空，就抛一个NPE。不过这里和Optional的设计理念不一样，Optional想从根源上去解决Null这个问题，而lombok的@NonNull只是保证了程序调用对象方法的时候，会对对象是否为空进行检查，如果为空就抛NPE。 那么使用和不使用都是会抛NPE，那么@NonNull 有什么用处呢，其实通过输出的异常堆栈我们就知道，使用 @NonNull使我们能够快速定位到错误出现的地方msg is marked @NonNull but is null 123456// 使用 @NonNullException in thread \"main\" java.lang.NullPointerException: msg is marked @NonNull but is null // 不使用 @NonNullException in thread \"main\" java.lang.NullPointerException 4、@Accessors在介绍生成器模式之前，我们可以试试链式调用风格来初始化我们的对象： 12345678910111213141516171819@Accessors(chain = true)@Setter@Getter@ToStringpublic class Person { private Integer id; private String name;}// 使用@Testpublic void accessorsTest() { Person person = new Person(); person.setId(100).setName(\"jack\"); System.out.println(person);} 为什么我们能连续set来形成链式 调用呢，通过反编译Person.class可以知道，在我们调用Person#setId的时候，给我返回了对象本身–this，所以我们可以继续调用对象的其他set方法。 1234567891011121314151617181920212223242526272829public class Person { private Integer id; private String name; public Person() { } public Person setId(Integer id) { this.id = id; return this; } public Person setName(String name) { this.name = name; return this; } public Integer getId() { return this.id; } public String getName() { return this.name; } public String toString() { return \"Person(id=\" + this.getId() + \", name=\" + this.getName() + \")\"; }} 5、@Builder说到生成器模式我们有些同学可能会感到陌生，但是类似下面这样的代码，我们肯定遇到过 1234Request request = new Request.Builder() .post(body) .url(url) .build(); 这是OkHttp构建request对象的api，这种方式来初始化对象并赋值的方式看起来比较优雅，这里我们可以借助lombok提供的@Builder 注解实现，如下： 123456789101112131415161718@Builder@ToStringpublic class LombokPerson2 { private Integer id; private String name; private String sex;}// 测试代码public static void main(String[] args) { LombokPerson2 person2 = LombokPerson2 .builder() .id(1) .name(\"laoWang\") .sex(\"男\") .build(); System.out.println(person2);} 目前我日常使用的几个注解已经介绍完毕，当然lombok提供的功能不止这些，如果你有兴趣可以自己搜索或者翻看下面这两篇博客。 Lombok：让JAVA代码更优雅 Java开发神器Lombok的使用与原理","link":"/2018/08/26/lombok/"},{"title":"使用Spring Cloud Gateway替换Zuul","text":"前言随着 Spring Cloud Netflix 家族宣布进入维护阶段，我也准备将 spinrg-cloud-in-action 进行相应的调整，计划使用 Spring Cloud Gateway 替代 Zuul，使用 Resilience4j 替换目前使用的 Hystrix ，这篇博客记录下整合 Spring Cloud Gateway 的一些过程。 Spring Cloud Gateway什么是 Spring Cloud Gateway ？ Spring Cloud Gateway 提供了一个建立在Spring Ecosystem之上的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。 Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为他们提供横切关注点，例如：安全性，监控/指标和弹性。 为什么要使用 Spring Cloud Gateway ？ 首先 Zuul 是基于servlet构建，使用阻塞API。它不支持任何长连接，如 websockets。 Spring Cloud Gateway 基于Spring Framework 5，Project Reactor 和 Spring Boot 2构建，使用非阻塞API。支持Websockets，而且它与 Spring 紧密集成，因此它能给开发人员带来更好的开发体验。 接下来讲介绍如何在项目中引入 Spring Cloud Gateway。 引入Spring Cloud Gateway首先我们在工程中引入相关依赖（以Maven为例） 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 不同于Zuul需要在启动类上添加 @EnableZuulProxy，使用spring cloud gateway我们无需通过注解开启网关功能，只需要在网关模块的application.yml中添加如下配置，便可开启通过服务中心自动（根据 serviceId ）创建路由。 123456spring: cloud: gateway: discovery: locator: enabled: true 远程调用选用的是 feign ，所以我们需要在 pom 文件中引入 feign 的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 通过在启动类上添加注解 @EnableFeignClients ，启用feign。关于远程调用这块的使用，和我们使用网关是什么没有关系，还是按照之前的使用方法，如下： 1234567@FeignClient(name = \"provider\")public interface HelloControllerRemote { @PostMapping(\"/hello\") String hello(@RequestParam(\"userName\") String userName);} @FeignClient(name = &quot;provider&quot;) 指定我们调用哪个微服务模块，通过 @PostMapping(&quot;/hello&quot;) 等来绑定调用的哪个接口。这样我们就可以在我们的 ConsumerHelloController里面注入该 HelloControllerRemote ,如下： 12345678910111213@RestControllerpublic class ConsumerHelloController { @Autowired private HelloControllerRemote helloControllerRemote; @ApiOperation(\"hello接口\") @PostMapping(\"/hello\") public String hello(@ApiParam(\"用户名\") String userName) { return helloControllerRemote.hello(userName); }} 验证 1curl -X PUT http://localhost:9999/CONSUMER/hello 注：我目前使用的是 spring-cloud-gateway-2.1.0.RELEASE ，使用feign调用consumer模块的接口，无法通过/consumer/hello 远程访问，而是调用 /CONSUMER/hello ，模块名需要大写。 整合swagger因为Spring Cloud Gateway 是基于webflux和Netty，而swagger(version: 2.9.2)目前还没有提供支持，所以我们要用webflux的方式提供swagger对外接口， 123456789101112131415161718192021222324252627282930@Componentpublic class SwaggerRouterFunction { @Autowired(required = false) private SecurityConfiguration securityConfiguration; @Autowired(required = false) private UiConfiguration uiConfiguration; @Autowired private SwaggerResourcesProvider swaggerResources; @Bean public RouterFunction&lt;?&gt; routerFunction() { return RouterFunctions .route(GET(\"/swagger-resources\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(swaggerResources.get()))) .andRoute(GET(\"/swagger-resources/configuration/ui\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(Optional.ofNullable(uiConfiguration) .orElse(UiConfigurationBuilder.builder().build())))) .andRoute(GET(\"/swagger-resources/configuration/security\"), request -&gt; ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON_UTF8) .body(fromObject(Optional.ofNullable(securityConfiguration) .orElse(SecurityConfigurationBuilder.builder().build())))); }} 除此之外，我们还要聚合swagger文档，需要提供 swaggerResource list ，我们是从RouteLocator中获取到routes信息，来实现自动聚合： 12345678910111213141516171819202122232425262728293031323334353637@Primary@Componentpublic class SwaggerProvider implements SwaggerResourcesProvider { @Value(\"${spring.application.name}\") public String applicationName; private final RouteLocator routeLocator; public SwaggerProvider(RouteLocator routeLocator) { this.routeLocator = routeLocator; } @Override public List&lt;SwaggerResource&gt; get() { List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;(); routeLocator.getRoutes().subscribe(route -&gt; { String routeUri = route.getUri().getHost(); if (!applicationName.equalsIgnoreCase(routeUri)) { resources.add(swaggerResource(routeUri, String.format(\"/%s/v2/api-docs\", routeUri))); } }); return resources; } private SwaggerResource swaggerResource(String name, String location) { SwaggerResource swaggerResource = new SwaggerResource(); swaggerResource.setSwaggerVersion(\"2.0\"); swaggerResource.setName(name); swaggerResource.setLocation(location); return swaggerResource; }} 然后我们启动注册中心，网关，provider，consumer 4个模块，访问 http://localhost:9999/swagger-ui.html#/ ，便能看到文档聚合后的效果。 源码详细代码见 spring-cloud-in-action","link":"/2019/03/09/spring-cloud-gateway-01/"},{"title":"Java8 Stream实战（二）","text":"前言实际工作中，我们面临的数据处理场景异常复杂，往往需要多种API组合使用。对于常见的处理需求，Java8提供了例如 Collectors 来协助我们处理集合，比如我们需要将流收集成一个ArrayList 的时候，我们可以直接使用java.util.stream.Collectors#toList，如下 1List collect = students.stream().collect(Collectors.toList()); 但是 Collectors#toList 的实现相较于上面的函数式编程API，显得不那么简单明了，反而有些复杂： 1234public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() { return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; { left.addAll(right); return left; }, CH_ID); 对于源码这里就不过多介绍，本次主要是记录工作中一些常见的数据处理场景中，一起看看Stream是如何体现其优势的。 Stream in action自定义分组 自定义分组（Map）的key &amp; value 12345// 根据学生编号分组，value为学生的姓名Map&lt;String, List&lt;String&gt;&gt; collect = students.stream().collect(Collectors.groupingBy( Student::getStudentNo, Collectors.mapping(Student::getName, Collectors.toList()))); collect.forEach((k, v) -&gt; System.out.printf(\"studentNo: [%s], name: %s \\n\", k, v)); 自定义去重利用Set去重1234567@Testpublic void generateTest2() { Set&lt;Student&gt; collect = students.stream().collect( Collectors.toCollection( () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getId))));} 上述是将 List 转换成 Set，从而利用 Set 的特性来完成去重，如果想收集的对象是 List ，可以参考下面代码： 1234List&lt;Student&gt; collect = students.stream().collect(Collectors.collectingAndThen( Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Student::getStudentNo))), ArrayList::new));collect.forEach(System.out::println); List 转换 Map工作中我们经常遇到根据ID 或者其他一些标识符将List转成Map的场景，对象的一个属性作为key，用来避免例如嵌套for循环。利用 Collectors#groupingBy 可以达到分组的效果，但是获取到的是 Map&lt;K, List&lt;V&gt;&gt; ,不方便我们使用，尽管有时候我们是根据主键（唯一）来分组，对于这样的key，只会存在一个value与之对应。那么我们如何获取到 Map&lt;K, V&gt; 呢，我们可以使用 Collectors#toMap ，JDK1.8中 toMap有三个重载方法， 1、如果能保证一个key只会对应一个value 1234Map&lt;String, String&gt; collect = STUDENTS.stream() .collect(Collectors.toMap(Student::getStudentNo, Student::getName));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v)); 2、如果一个key可能对应多个value（只保留其中一个value） 1234Map&lt;String, String&gt; collect = STUDENTS.stream().collect(Collectors.toMap( Student::getStudentNo, Student::getName, (s1, s2) -&gt; s1));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v)); 3、如果一个key可能对应多个value（只保留其中一个value），但是想以非HashMap 来作为容器 1234Map&lt;String, String&gt; collect = STUDENTS.stream().collect(Collectors.toMap( Student::getStudentNo, Student::getName, (s1, s2) -&gt; s1, TreeMap::new));collect.forEach((k, v) -&gt; System.out.printf(\"key: %s , value: %s \\n\", k, v));","link":"/2019/05/26/stream-in-action-02/"},{"title":"Java8 Stream实战（三）","text":"前言本想接着上一章 Java8 Stream实战（二） 继续往后开展 Java8 Stream 相关API实践，但是考虑到今天要介绍的内容不仅仅只是针对现有 API ，还有如何对 Stream#reduce 进行相关的拓展，以满足日常开发的需要，于是单独开一篇进行介绍。 开始Reduce of BIgdecimal 注：Stream#reduce 有三个重载方法，本篇对此不多赘述，有兴趣可以查阅《Java 8 in Action》 为什么会有这篇章节呢？日常开发中我们会遇到如下场景 123int sum = list.stream().mapToInt(XXXBean::getIntValue).sum();int max = list.stream().mapToInt(XXXBean::getIntValue).max().orElse(0);int min = list.stream().mapToInt(XXXBean::getIntValue).min().orElse(0); sum() 、max()、min() 函数是 java.util.stream.IntStream 像我们提供的，我们可以很方便的利用这些函数来完成求和、取最大值、取最小值等等操作。 可是有时候整形（如上述代码 int）不能满足我们一些对精度有着较高要求的场景，如金钱、重量等等。针对这些场景我们可能会使用BIgdecimal，这时候我们不得不使用 Stream#reduce 来自定义（如下面代码针对的BIgdecimal）Stream 收集行为，而本小节则是对一些常见场景的收集行为进行封装以达到复用的目的。 注：关于BIgdecimal 的封装工具类为 BigDecimals ，以下代码只包含方法部分代码 sum1234public static BigDecimal sum(BigDecimal b1, BigDecimal b2) { Assert.isTrue(b1 != null &amp;&amp; b2 != null, \"arguments of BigDecimals#sum is not allowed be null.\"); return b1.add(b2);} max1234public static BigDecimal max(BigDecimal b1, BigDecimal b2) { Assert.isTrue(b1 != null &amp;&amp; b2 != null, \"arguments of BigDecimals#max is not allowed be null.\"); return b1.compareTo(b2) &gt; 0 ? b1 : b2;} min1234public static BigDecimal min(BigDecimal b1, BigDecimal b2) { Assert.isTrue(b1 != null &amp;&amp; b2 != null, \"arguments of BigDecimals#min is not allowed be null.\"); return b1.compareTo(b2) &lt; 0 ? b1 : b2; } 为了方便测试，我们在BIgdecimals 中提供了生成集合的静态方法 1234567891011121314151617181920212223public static List&lt;Person&gt; getPersons() { Random random = new Random(); return Stream.generate(() -&gt; random.nextInt(6)).limit(20).map(num -&gt; { Person person = new Person(); person.setId(num); person.setUsername(\"name\" + num); person.setAccount(BigDecimal.valueOf(num)); return person; }).collect(Collectors.toList());}@Data@AllArgsConstructor@NoArgsConstructorpublic static class Person { private int id; private String username; private BigDecimal account;} 测试12345678910111213141516171819@Testpublic void customBigDecimalReduce() { BigDecimal sum = Stream.iterate(BigDecimal.ZERO, n -&gt; n.add(BigDecimal.ONE)).limit(20).reduce(BigDecimals::sum).orElse(BigDecimal.ZERO); BigDecimal max = Stream.iterate(BigDecimal.ZERO, n -&gt; n.add(BigDecimal.ONE)).limit(20).reduce(BigDecimals::max).orElse(BigDecimal.ZERO); BigDecimal min = Stream.iterate(BigDecimal.ZERO, n -&gt; n.add(BigDecimal.ONE)).limit(20).reduce(BigDecimals::min).orElse(BigDecimal.ZERO); List&lt;BigDecimals.Person&gt; persons = BigDecimals.getPersons(); System.out.println(\"persons: \" + persons); Map&lt;String, BigDecimal&gt; complexSum = persons.stream() .filter(person -&gt; person.getId() != 0) .collect(Collectors.toMap(BigDecimals.Person::getUsername, BigDecimals.Person::getAccount, BigDecimals::sum)); // print System.out.println(\"sum: \" + sum); System.out.println(\"max: \" + max); System.out.println(\"min: \" + min); System.out.println(\"complexSum: \" + complexSum);} 因为生成测试集合的方法 BigDecimals#getPersons 存在随机性，如下结果仅代表本人电脑本次测试结果，如下： 12345persons: [BigDecimals.Person(id=0, username=name0, account=0), BigDecimals.Person(id=2, username=name2, account=2), BigDecimals.Person(id=5, username=name5, account=5), BigDecimals.Person(id=3, username=name3, account=3), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=5, username=name5, account=5), BigDecimals.Person(id=2, username=name2, account=2), BigDecimals.Person(id=2, username=name2, account=2), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=4, username=name4, account=4), BigDecimals.Person(id=1, username=name1, account=1), BigDecimals.Person(id=1, username=name1, account=1)]sum: 190max: 19min: 0complexSum: {name5=10, name4=24, name3=3, name2=6, name1=7}","link":"/2019/09/16/stream-in-action-03/"},{"title":"Java源码解读(一)：Objects","text":"其实阅读Java源码本身并没有那么难，只要我们踏出第一步，后面反而比我们想象的要简单。可能很多Java初学者并不知道从哪里下手，所以本篇博客将挑选一个源码较为简单的工具类—— java.util.Objects 作为切入点，走入Java源码的世界。 相关说明 IDE： IDEA Java Version： 1.8.0_161 ObjectsObjects 位于 java.util 包下，看名称就能知道是一个工具类，除去私有的构造方法外，只有12个静态方法供我们使用，为了方便阅读，这里我已经去掉注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package java.util;import java.util.function.Supplier;public final class Objects { private Objects() { throw new AssertionError(\"No java.util.Objects instances for you!\"); } public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;&amp; a.equals(b)); } public static boolean deepEquals(Object a, Object b) { if (a == b) return true; else if (a == null || b == null) return false; else return Arrays.deepEquals0(a, b); } public static int hashCode(Object o) { return o != null ? o.hashCode() : 0; } public static int hash(Object... values) { return Arrays.hashCode(values); } public static String toString(Object o) { return String.valueOf(o); } public static String toString(Object o, String nullDefault) { return (o != null) ? o.toString() : nullDefault; } public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c) { return (a == b) ? 0 : c.compare(a, b); } public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } public static &lt;T&gt; T requireNonNull(T obj, String message) { if (obj == null) throw new NullPointerException(message); return obj; } public static boolean isNull(Object obj) { return obj == null; } public static boolean nonNull(Object obj) { return obj != null; } public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) { if (obj == null) throw new NullPointerException(messageSupplier.get()); return obj; }} 看上去很熟悉，并不会很陌生对吧，其实阅读源码也没有想象的那么难。 构造方法这个工具类首先引入眼帘的便是其私有的构造方法： 123private Objects() { throw new AssertionError(\"No java.util.Objects instances for you!\");} 如果你有阅读上面的源码就会发现，Objects 提供的方法除此外皆为静态方法，当我们使用这些方法的时候无需显示实例化对象，而是直接通过 类名.方法名() 来调用其提供的方法，而私有其构造方法便是以防我们无意义创建对象浪费空间，所以这里抛出一个断言异常—— &quot;No java.util.Objects instances for you!&quot;。 说到构造方法私有化想必大家有点耳熟，没错，我们在学习单例模式的时候便将对象的构造方法私有化，不允许用户去 new 该对象，而是通过我们提供的方法去获取已经创建好的实例。 equals接下来我们正式开始介绍 Objects 最为常用的方法 equals ： 123public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;&amp; a.equals(b));} 这也很简单对吧，我们也写过这样的代码，判断两个对象是否相等，代码就一行，翻译一下就是判断参数列表中的两个对象是否为同一个对象（引用是否指向同一内存地址），或者在参数 a 不为 null 的情况下，调用 a 的 equals 方法，而a的 equals 方法要看其具体的实现，如果是Object（所有对象的父类），则： 1234public boolean equals(Object obj) { // 判断是否为同一对象，即引用是否指向同一内存地址 return (this == obj);} equals of String但这不能满足我们日常使用需求，实际开发过程中，假如 Student 的 id 相同，那么我们就可以认为 equals 为 true ，所以Object的equals方法并不能满足这种情况，所以有必要的时候大家都会重写一下equals方法（重写 equals 方法的同时最好重写一下 hashCode ），这里就介绍一下String的equals实现（为了方便阅读，我添加了些许注释）： 1234567891011121314151617181920212223242526272829public boolean equals(Object anObject) { if (this == anObject) { // 判断是否为同一对象 return true; } if (anObject instanceof String) { // 如果anObject是String的实例（通俗来讲就是String是否为String类型） // 如果是，则强转为String类型（通过instanceof判断避免类型转化异常） String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { // 其实阅读过String源码我们就明白这里的用途（String底层使用的是char[]数组） // 1、判断底层数组的长度，如果不想等说明两个字符肯定不一样，就无需继续判断 // 2、如果是，一个字符一个字符去判断是否相等 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // 从最后一个字符开始对比 if (v1[i] != v2[i]) // 如果同一位置的字符不相等，则字符串不相等 return false; i++; } return true; } } return false; } 可能大家对最后一段 while 那里有点疑惑，其实我们完全可以用 for 来替代 while ： 123456789101112131415int n = value.length;...int i = 0;while (n-- != 0) { if (v1[i] != v2[i]) return false; i++;}// 上面while的写法可以用for改写for (int i = 0; i &lt; value.length; i++) { if (v1[i] != v2[i]) { return false; }} 其实第一次看到 String 的 equals 方法就差点笑出声，感觉这个作者写的小心翼翼（提高性能），判断字符串是否相等经历如下步骤： 判断两个对象是否相等，对象都想相等了，我们还用判断吗？ 什么？对象不相等，那么只能遍历 char[] 一个个字符去判断了。。。不对！如果数组长度不一样那肯定也不相等，所以我们在循环前线判断一下字符串底层数组的长度吧。 oops！连底层数组长度都一样，这下没办法了，老老实实去一个个判断吧，还好只要判断相同位置上的字符是否相等就行，一个 for 循环搞定！ 说好的阅读 Objects 源码，去花费大量篇章去介绍 String 的 equsla 方法了，赶紧回到正题。 其实Objects.equals() 实现还是通过调用其 参数的自身实现，不过在这之前贴心的帮我们做了非空判断以及一些优化—— a == b ，没错，就是这个小小的 a == b ,为什么说是优化呢？首先是避免空指针异常，其次是通过String的equals方法我们知道，判断两个字符串是否相等的原理是一个一个去对比其底层char数组里面的元素，但是如果a b 是同一对象，我们判断其内存地址便可，比对底层数组里面的元素未免显得有些浪费性能了。 其他篇幅有限，其他方法无法一个个扩展开来去讲，就稍微介绍一下吧： deepEquals 是通过Arrays.deepEquals0() 来支持两个数组是否相等（顺序），如果对象不是数组，则返回false； hashCode 调用了对象自身的 hashCode 实现 hash 调用了Arrays.hashCode 的实现，来计算数组的 hash 值 toString 是调用了 String.valueOf 方法,这点和Object 的实现不一样（Object 为getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) ） oString(Object o, String nullDefault) 如果对象本身不为空则调用其toString方法，为空就使用其默认值nullDefault compare(T a, T b, Comparator&lt;? super T&gt; c) 方法，如果我们了解过Java8的新特性就会知道这么一个词——行为参数话，就拿Student 对象来举例，compare两个Student，我们可以compare的属性有很多，比如年龄，身高，成绩等等。这样就导致一个compare方法我们可能要重载多次，但是通过行为参数化，我们将比较的这个行为（比较年龄？比较身高？）当作参数传入，就只用写一个compare方法，比如这里面的最后一个参数——Comparator&lt;? super T&gt; c，这是一个函数式接口，是我们进行对象比较的具体行为，可以参考我之前写的 行为参数化 这篇文章 以及一些针对null封装的一些方法，自行阅读即可。 Java的源码解读是我很早就想做的一件事，但由于自身水平所限，写出来的文章达不到我理想的效果，请多见谅。","link":"/2019/01/13/source-of-objects-in-java/"},{"title":"Spring Extensions (一) Bean的动态注册","text":"前言在认识BeanDefinitionRegistryPostProcessor 和 ClassPathBeanDefinitionScanner 之前，需要说明一下为什么会有这篇文章？动态注册Bean ？日常开发中我们有太多方式来定义注册Bean实例到Spring容器中： 通过xml的方式配置注册 通过@Component 以及其派生注解注册 通过@Bean注册 … 那为什么还需要去动态注册Bean 呢？就算需要动态注册Bean，完全可以不使用上诉方式——比如使用 @Conditional 系列条件注解（当符合条件的时候才会注册Bean），@Profile 在指定的环境下才会被注册（ @Conditional 的一种）等等，这里我们就不往下展开了。 虽然标题为Bean的动态注册 ，但是日常开发过程中我们完全可以使用 @Conditional 家族的条件注解，足以满足绝大多数场景。其实写这篇文章主要是因为最近在看 Mybatis 整合 Spring （mybatis-spring 模块）,了解Mapper 是如何被作为Bean被注册到Ioc容器中后的一些感想，以博客的方式呈现出来，在此特别说明一下。 接下来的内容主要是简化 Mybatis 整合 Spring 的例子来介绍Bean的动态注册 引出问题我们先通过 Mybatis 官网 上的一段代码回顾其单独使用时步骤： 1234567String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);} 熟悉Mybatis的同学应该都知道，这里的BlogMapper 是一个接口，并且我们没有定义其实现类，当我们执行BlogMapper mapper = session.getMapper(BlogMapper.class) 的时候，返回的对象其实是一个动态代理类，具体细节这里先不做讲解，有兴趣可以阅读 tiny-frameworks 中的tiny-mybatis 模块。 当我们整合Spring后，上诉的对象管理可以移交给Spring，我们只需注入所需的 Mapper ： 12345678910@Servicepublic class BlogService { @Autowired private BlogMapper mapper; public Blog selectBlog(Integer blogId) { return mapper.selectBlog(101); }} 能通过@Autowired 的方法注入 Bean ，说明整合Spring后，Mapper 被注册到 Ioc容器中，为了展示这个过程，接下来将通过一个小小的 Demo 去模拟 Mapper的动态注册的过程。 Mapper 动态注册定义Mapper首先我们需要提供一个测试接口 TestMapper ： 123456public interface TestMapper { String name(); String echo();} 提供FactoryBean因为 BeanDefinition 需要设置一个BeanClass, 这里我们需要额外提供一个FactoryBean，用于动态生成其代理类，如下： 123456789101112131415161718192021222324252627282930@Slf4jpublic class TinyMapperFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt; { private Class&lt;?&gt; interfaceClass; public TinyMapperFactoryBean() { } public TinyMapperFactoryBean(Class&lt;?&gt; interfaceClass) { this.interfaceClass = interfaceClass; } @SuppressWarnings(\"unchecked\") @Override public T getObject() throws Exception { return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[]{interfaceClass}, (proxy, method, args) -&gt; { if (method.getName().equals(\"toString\")) { return interfaceClass.getSimpleName(); } // 如果返回值为 String 则返回方法名称 return \"proxy: \" + method.getName(); }); } @Override public Class&lt;?&gt; getObjectType() { return interfaceClass; }} 自定义Scanner我们可以通过 BeanDefinitionRegistry#registerBeanDefinition 来注册BeanDefinition， 也可以配合 ClassPathBeanDefinitionScanner 来实现自动扫描注册（根据一定的规则去扫描指定路径下的Class来作为候选BeanDefinition），通过继承ClassPathBeanDefinitionScanner 来扩展自己的 Scanner，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Slf4jpublic class TinyMapperScanner extends ClassPathBeanDefinitionScanner { private Class&lt;? extends Annotation&gt; annotationClass; public TinyMapperScanner(BeanDefinitionRegistry registry) { super(registry); } public void setAnnotationClass(Class&lt;? extends Annotation&gt; annotationClass) { this.annotationClass = annotationClass; } @Override protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) { log.warn(\"No target mapper was found in '\" + Arrays.toString(basePackages) + \"' package. Please check your configuration.\"); } else { processBeanDefinitions(beanDefinitions); } return beanDefinitions; } private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) { beanDefinitions.forEach(holder -&gt; { GenericBeanDefinition beanDefinition = (GenericBeanDefinition) holder.getBeanDefinition(); beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName()); beanDefinition.setBeanClass(TinyMapperFactoryBean.class); beanDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); log.info(\"==&gt; {} process finished\", beanDefinition.getBeanClassName()); }); } /** * copy form {@code org.mybatis.spring.mapper.ClassPathMapperScanner#registerFilters} */ public void registerFilters() { boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) { addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; } if (acceptAllInterfaces) { // default include filter that accepts all classes addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; true); } // exclude package-info.java addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; { String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith(\"package-info\"); }); } /** * {@inheritDoc} */ @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent(); }} 这里需要说明一下: 通过 TinyMapperScanner#registerFilters, 我可以注册一些过滤器，上诉实现是复制于mybatis 的 ClassPathMapperScanner#registerFilters 。 当调用 ClassPathBeanDefinitionScanner#doScan 的时候，默认的 ClassPathScanningCandidateComponentProvider#isCandidateComponent(AnnotatedBeanDefinition)会过滤掉接口，我们需要重写这个方法的实现，以确保返回Mapper接口的 BeanDefinition 。 BeanDefinitionRegistry我们选择自定义的 TinyMapperScanner来实现 BeanDefinition 自动扫描注册，通过实现 BeanDefinitionRegistryPostProcessor 接口来获取 BeanDefinitionRegistry： 12345678910111213141516@Componentpublic class TinyMapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { TinyMapperScanner scanner = new TinyMapperScanner(registry); scanner.setAnnotationClass(null); scanner.registerFilters(); scanner.doScan(\"com.github.byference.extensions.registrar.mapper\"); } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { }} 测试最后我们可以写一个单元测试： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class RegistrarApplicationTests { @Autowired private TestMapper testMapper; @Test public void testMapperTest() { assert \"proxy: name\".equals(testMapper.name()); assert \"proxy: echo\".equals(testMapper.echo()); }} 总结通过了解Bean的动态注册，能进一步的了解Spring的一些运行机制，以及其他框架整合Spring的一些实现方式，做到举一反三——例如各大 RPC 框架整合Spring的过程~","link":"/2019/10/03/spring-extensions-01/"},{"title":"Spring Async 实战 & 源码","text":"前言什么是异步调用？什么时候需要异步调用？ 相信大家日常开发过程中，大部分场景使用的是同步的方式来处理。但是当我遇到如下场景如： 执行一次请求需要执行 A（调用第三方API获取信息数据a）消耗200ms， B（根据条件去数据库查询或RPC接口获取信息数据b）消耗150ms， C（组装a，b）消耗20ms。 同步：C等待B执行完成，B等待A执行完成，结果为370ms 异步：C等待A、B（并行）执行完成，结果为220ms 注：以上仅举例介绍异步在特殊场景下带来的性能优势，不考虑网络以及线程切换等带来的开销，数据无参考价值。 异步带来的性能优势不言而喻，当处理一些无需同步返回操作的时候尤为明显（不会阻塞当前线程、可并行等）。比如发送邮件（也可以选择MQ），写日志表等等。话不多说，接下来便进入实战环节~ 快速开始 JDK Version：1.8 Spring Version:：5.1.3 启用异步@EnableAsync 启用异步（自动装配） 12345678@EnableAsync@SpringBootApplicationpublic class SamplesWithoutDbApplication { public static void main(String[] args) { SpringApplication.run(SamplesWithoutDbApplication.class, args); }} 编写代码@Async 给方法赋予异步执行的能力 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Slf4j@Servicepublic class AsyncService { ... /** * 异步执行：有返回值 */ @Async public Future&lt;String&gt; supplyAsync() { String result = \"fail\"; try { // sleep 2 seconds TimeUnit.SECONDS.sleep(2); log.info(\"[{}] - supplyAsync end at {}.\", Thread.currentThread().getName(), LocalDateTime.now()); result = \"hello world...\"; } catch (InterruptedException e) { e.printStackTrace(); } return new AsyncResult&lt;&gt;(result); } /** * 异步执行：无返回值 */ @Async public void runAsync() { try { // sleep 2 seconds TimeUnit.SECONDS.sleep(2); log.info(\"[{}] - runAsync end at {}.\", Thread.currentThread().getName(), LocalDateTime.now()); } catch (InterruptedException e) { e.printStackTrace(); } } ...} 暴露服务接口 123456789101112131415161718192021222324@Slf4j@RestControllerpublic class AsyncController { @Autowired private AsyncService asyncService; @RequestMapping(\"supplyAsync\") public String supplyAsync() throws Exception { Future&lt;String&gt; asyncResult = asyncService.supplyAsync(); log.info(\"supply async has returned...\"); return asyncResult.get(3, TimeUnit.SECONDS); } @RequestMapping(\"runAsync\") public void runAsync() { asyncService.runAsync(); log.info(\"run async has returned...\"); }} 验证122019-09-13 21:28:46.914 INFO 2064 --- [io-18080-exec-1] c.g.b.s.controller.AsyncController : run async has returned...2019-09-13 21:28:48.920 INFO 2064 --- [ task-1] c.g.b.samples.service.AsyncService : [task-1] - runAsync end at 2019-09-13T21:28:48.920. 通过日志我们能发现执行 AsyncService#runAsync 的线程名称为 task-1 ，而执行响应的线程为 io-18080-exec-1 ，异步调用成功。 源码解读原理猜测日常环节，在翻源码之前，我们不妨猜测一下Spring Async 的实现原理——动态代理，下面是猜测的伪代码： 123executorService.execute(() -&gt; { method.invoke(obejct, args);}); 源码验证我们带着猜测，从 @EnableAsync 注解入手： 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AsyncConfigurationSelector.class)public @interface EnableAsync { ...} 会心一笑，你看到了 @Import(AsyncConfigurationSelector.class) ，二话不说，直接点进 AsyncConfigurationSelector 123456789101112131415161718192021222324public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; { private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME = \"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration\"; /** * Returns {@link ProxyAsyncConfiguration} or {@code AspectJAsyncConfiguration} * for {@code PROXY} and {@code ASPECTJ} values of {@link EnableAsync#mode()}, * respectively. */ @Override @Nullable public String[] selectImports(AdviceMode adviceMode) { switch (adviceMode) { case PROXY: return new String[] {ProxyAsyncConfiguration.class.getName()}; case ASPECTJ: return new String[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME}; default: return null; } }} 这里提供了两种自动装配类，那么程序走的是 PROXY 还是 ASPECTJ 呢？AsyncConfigurationSelector#selectImports 上的Java Doc 给了我们提示，我们查看一下 EnableAsync#mode()， 1AdviceMode mode() default AdviceMode.PROXY; 默认是 AdviceMode.PROXY ， 所以装配的是 ProxyAsyncConfiguration，而通过debug也能证实这一点，那么我们转移到 ProxyAsyncConfiguration 中 1234567891011121314151617181920@Configuration@Role(BeanDefinition.ROLE_INFRASTRUCTURE)public class ProxyAsyncConfiguration extends AbstractAsyncConfiguration { @Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public AsyncAnnotationBeanPostProcessor asyncAdvisor() { Assert.notNull(this.enableAsync, \"@EnableAsync annotation metadata was not injected\"); AsyncAnnotationBeanPostProcessor bpp = new AsyncAnnotationBeanPostProcessor(); bpp.configure(this.executor, this.exceptionHandler); Class&lt;? extends Annotation&gt; customAsyncAnnotation = this.enableAsync.getClass(\"annotation\"); if (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, \"annotation\")) { bpp.setAsyncAnnotationType(customAsyncAnnotation); } bpp.setProxyTargetClass(this.enableAsync.getBoolean(\"proxyTargetClass\")); bpp.setOrder(this.enableAsync.&lt;Integer&gt;getNumber(\"order\")); return bpp; }} 这个配置类给我们装配了一个 AsyncAnnotationBeanPostProcessor Bean，然后继续往下翻 -&gt; AsyncAnnotationAdvisor -&gt; AnnotationAsyncExecutionInterceptor ， 而 AnnotationAsyncExecutionInterceptor 本身只是重写了一个 #getExecutorQualifier，我们将目光投向他的父类——AsyncExecutionInterceptor，在这个类中，我们看到了一个熟悉的方法名 AsyncExecutionInterceptor#invoke， 我们最开始猜测 Spring Async 是通过动态代理来实现的，看到这更一步确定了我们的猜测 123456789101112131415161718192021222324252627282930313233343536373839public class AsyncExecutionInterceptor extends AsyncExecutionAspectSupport implements MethodInterceptor, Ordered { ... @Override @Nullable public Object invoke(final MethodInvocation invocation) throws Throwable { Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass); final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod); AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod); if (executor == null) { throw new IllegalStateException( \"No executor specified and no default executor set on AsyncExecutionInterceptor either\"); } Callable&lt;Object&gt; task = () -&gt; { try { Object result = invocation.proceed(); if (result instanceof Future) { return ((Future&lt;?&gt;) result).get(); } } catch (ExecutionException ex) { handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments()); } catch (Throwable ex) { handleError(ex, userDeclaredMethod, invocation.getArguments()); } return null; }; return doSubmit(task, executor, invocation.getMethod().getReturnType()); } ...} 通过上诉代码我们可知，Spring Async 将 invocation.proceed() 封装到了 一个 Callable 中，然后调用了其父类的 AsyncExecutionAspectSupport#doSubmit 12345678910111213141516171819202122232425public abstract class AsyncExecutionAspectSupport implements BeanFactoryAware { @Nullable protected Object doSubmit(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType) { if (CompletableFuture.class.isAssignableFrom(returnType)) { return CompletableFuture.supplyAsync(() -&gt; { try { return task.call(); } catch (Throwable ex) { throw new CompletionException(ex); } }, executor); } else if (ListenableFuture.class.isAssignableFrom(returnType)) { return ((AsyncListenableTaskExecutor) executor).submitListenable(task); } else if (Future.class.isAssignableFrom(returnType)) { return executor.submit(task); } else { executor.submit(task); return null; } }} 这里是通过使用 JDK1.8 提共的 CompletableFuture#supplyAsync 来实现异步调用，所以我们如果不使用Spring Async ，可以借助 CompletableFuture 来实现异步调用，重构的代码如下： 12345678910111213public void runAsyncByThreadPool() { CompletableFuture.runAsync(() -&gt; { try { // sleep 2 seconds TimeUnit.SECONDS.sleep(2); log.info(\"[{}] - runAsyncByThreadPool end at {}.\", Thread.currentThread().getName(), LocalDateTime.now()); } catch (InterruptedException e) { e.printStackTrace(); } });} 注：有返回值可以使用 CompletableFuture#supplyAsync 扩展Spring 提供了 RequestContextHolder#getRequestAttributes() 静态方法供我们获取到当前上下文的 request，通过的是 ThreadLocal，但是我们执行方法异步调用的时候切换了线程，所以是无法通过 RequestContextHolder#getRequestAttributes()获取到 request ，如下会输出 &quot;request is null&quot; 1234567891011121314@Asyncpublic void runAsyncWithRequest() { ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (requestAttributes != null) { HttpServletRequest request = requestAttributes.getRequest(); log.info(\"[{}] - runAsyncWithRequest end at {}.\", Thread.currentThread().getName(), LocalDateTime.now()); log.info(\"==&gt; {}: {}\", request.getMethod().toUpperCase(), request.getRequestURI()); } else { log.info(\"request is null\"); }} 那么要如何处理呢？ 我们知道 ThreadPoolTaskExecutor 提供了#setTaskDecorator 方法，可以围绕任务的调用设置一些执行上下文，通过之前的代码阅读，我们知道 Spring Async 通过 CompletableFuture#supplyAsync 实现异步的，而 CompletableFuture 是提供了重载方法方便我们指定 task 执行的线程池，那么我们只需要替换 Spring Async 指定的线程池即可 通过阅读源码发现， Spring Async 提供的 executor 是通过 AsyncExecutionAspectSupport#determineAsyncExecutor 通过调用this.executors.get(method)提供的 12345678910111213141516171819202122protected AsyncTaskExecutor determineAsyncExecutor(Method method) { AsyncTaskExecutor executor = this.executors.get(method); if (executor == null) { Executor targetExecutor; // qualifier 是 Async#value，我们没有设置，所以为null String qualifier = getExecutorQualifier(method); if (StringUtils.hasLength(qualifier)) { targetExecutor = findQualifiedExecutor(this.beanFactory, qualifier); } else { // 从defaultExecutor获取一个 executor 赋值给 targetExecutor targetExecutor = this.defaultExecutor.get(); } if (targetExecutor == null) { return null; } executor = (targetExecutor instanceof AsyncListenableTaskExecutor ? (AsyncListenableTaskExecutor) targetExecutor : new TaskExecutorAdapter(targetExecutor)); this.executors.put(method, executor); } return executor;} 当Spring 加载AsyncExecutionAspectSupport 的时候会初始化 executors ——一个 size 为0 的 ConcurrentHashMap 1private final Map&lt;Method, AsyncTaskExecutor&gt; executors = new ConcurrentHashMap&lt;&gt;(16); 而 executors 只有当 this.executors.get(method) == null 的时候才会创建一个 executor 并 put 进去，通过上述代码可知，当我们没有设置Async#value 的时候，程序会从defaultExecutor获取一个 executor 提供给CompletableFuture，而 defaultExecutor 是通过AsyncExecutionAspectSupport#getDefaultExecutor获取，代码如下 1234567rotected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) { if (beanFactory != null) { try { return beanFactory.getBean(TaskExecutor.class); } ...} Spring 在 TaskExecutionAutoConfiguration#applicationTaskExecutor 里面给我们提供了一个TaskExecutor Bean， 12345678910111213141516171819202122@Bean@ConditionalOnMissingBeanpublic TaskExecutorBuilder taskExecutorBuilder() { TaskExecutionProperties.Pool pool = this.properties.getPool(); TaskExecutorBuilder builder = new TaskExecutorBuilder(); builder = builder.queueCapacity(pool.getQueueCapacity()); builder = builder.corePoolSize(pool.getCoreSize()); builder = builder.maxPoolSize(pool.getMaxSize()); builder = builder.allowCoreThreadTimeOut(pool.isAllowCoreThreadTimeout()); builder = builder.keepAlive(pool.getKeepAlive()); builder = builder.threadNamePrefix(this.properties.getThreadNamePrefix()); builder = builder.customizers(this.taskExecutorCustomizers); builder = builder.taskDecorator(this.taskDecorator.getIfUnique()); return builder;}@Lazy@Bean(name = APPLICATION_TASK_EXECUTOR_BEAN_NAME)@ConditionalOnMissingBean(Executor.class)public ThreadPoolTaskExecutor applicationTaskExecutor(TaskExecutorBuilder builder) { return builder.build();} 通过@ConditionalOnMissingBean(Executor.class)我们发现当Spring 不存在 Executor 这个Bean 的时候才会创建，这样就方便我们扩展，我们可以自己顶一个Executor 去覆盖掉默认实现， 1234567891011121314151617181920212223242526@Beanpublic Executor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setQueueCapacity(100); executor.setCorePoolSize(10); executor.setMaxPoolSize(10); executor.setAllowCoreThreadTimeOut(true); executor.setKeepAliveSeconds(60); executor.setThreadNamePrefix(\"task-executor-\"); executor.setTaskDecorator(runnable -&gt; { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); return () -&gt; { try { RequestContextHolder.setRequestAttributes(requestAttributes); runnable.run(); } finally { RequestContextHolder.resetRequestAttributes(); } }; }); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor;} 最后启动程序，调用runAsyncWithRequest方法，输出日志如下 1232019-09-13 23:22:46.001 INFO 8772 --- [io-18080-exec-1] c.g.b.s.controller.AsyncController : runAsync with request has returned...2019-09-13 23:22:46.007 INFO 8772 --- [task-executor-1] c.g.b.samples.service.AsyncService : [task-executor-1] - runAsyncWithRequest end at 2019-09-13T23:22:46.007.2019-09-13 23:22:46.007 INFO 8772 --- [task-executor-1] c.g.b.samples.service.AsyncService : ==&gt; POST: /runAsyncWithRequest 完结~","link":"/2019/09/13/spring-async-in-action/"},{"title":"Spring Retry 实战 & 源码","text":"前言 To make processing more robust and less prone to failure, it sometimes helps to automatically retry a failed operation, in case it might succeed on a subsequent attempt. Errors that are susceptible to this kind of treatment are transient in nature. For example, a remote call to a web service or an RMI service that fails because of a network glitch or a DeadLockLoserException in a database update may resolve itself after a short wait. To automate the retry of such operations, Spring Retry has the RetryOperations strategy. 日常开发中，我们无法避免在调用远程Web服务时候因为网络故障或数据库死锁等原因导致的调用失败，有时候这些故障会在短暂的等待后自行恢复，而为了自动重试这些操作，我们可以选择引入 Spring Retry . 快速开始 本文引入的 spring-retry 版本为 1.2.2RELEASE ， aspectjweaver 版本为1.9.2 引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt; 启用1234567891011121314151617// 启动类开启Spring Retry自动装备: @EnableRetry@EnableRetry@SpringBootApplicationpublic class SamplesWithoutDbApplication { public static void main(String[] args) { SpringApplication.run(SamplesWithoutDbApplication.class, args); }}// 方法开启Spring Retry@Retryable(value = Exception.class, maxAttempts = 2, backoff = @Backoff(delay = 2000L, multiplier = 1.5))@Overridepublic void sendMessage(String message) { ...} @Retryable 简介123456789101112131415161718192021222324252627282930313233343536373839404142434445@Target({ ElementType.METHOD, ElementType.TYPE })@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Retryable { /** * 重试侦听器bean名称，与其他属性互斥。 */ String interceptor() default \"\"; /** * 可重试的异常类型，includes的同义词。默认为空（如果excludes也为空，则重试所有异常）。 */ Class&lt;? extends Throwable&gt;[] value() default {}; /** * 可重试的异常类型，默认为空（如果excludes也为空，则重试所有异常）。 */ Class&lt;? extends Throwable&gt;[] include() default {}; /** * 无需重试的异常类型。默认为空（如果includes也为空，则重试所有异常）。 */ Class&lt;? extends Throwable&gt;[] exclude() default {}; ... /** * 最大尝试次数（包括第一次失败），默认为3 */ int maxAttempts() default 3; /** * 计算最大尝试次数表达式（包括第一次失败） */ String maxAttemptsExpression() default \"\"; /** * 重试等待策略 */ Backoff backoff() default @Backoff(); ...} @Backoff 简介1234567891011121314151617181920212223242526272829303132333435@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(RetryConfiguration.class)@Documentedpublic @interface Backoff { /** * 同 delay */ long value() default 1000; /** * 以毫秒为单位的延迟时间。 */ long delay() default 0; /** * 两次重试之间的最大等待时间（毫秒）。如果小于delay()，则应用默认值30000。 */ long maxDelay() default 0; /** * 如果为正，则用作生成下一个延迟的倍数。 */ double multiplier() default 0; ... /** * 当 multiplier() &gt; 0，将此值设置为true，使延迟随机化， * 以便最大延迟是前一个延迟的倍数，并且两个值之间的分布是均匀的。 */ boolean random() default false;} 测试1234567...2019-09-08 17:53:14.052 INFO 2200 --- [io-18080-exec-1] c.g.b.s.service.impl.UserServiceImpl : 2019-09-08T17:53:14.052 :start send message...2019-09-08 17:53:16.054 INFO 2200 --- [io-18080-exec-1] c.g.b.s.service.impl.UserServiceImpl : 2019-09-08T17:53:16.054 :start send message...2019-09-08 17:53:16.062 ERROR 2200 --- [io-18080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalArgumentException: Send message is not allowed to be empty] with root causejava.lang.IllegalArgumentException: Send message is not allowed to be empty... 因为代码里面maxAttempts 设置为2，所以在重试2次后依旧异常的情况下，抛出异常。 源码解读在翻源码之前，我们可以大胆的猜测一下，Spring Retry的实现原理——动态代理，下面是猜测的伪代码： 1234567try { method.invoke(obejct, args);} catch (Exception e) { if (canRetry()) { doRetry(); }} 然后我们带着猜测，从我们引入依赖后敲的第一个 Spring Retry 的注解 @EnableRetry 入手 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@EnableAspectJAutoProxy(proxyTargetClass = false)@Import(RetryConfiguration.class)@Documentedpublic @interface EnableRetry { boolean proxyTargetClass() default false;} 熟悉Spring Boot的小伙伴可能此时会心一笑，没错Spring Boot中大量使用的EnableXXX注解通过@Import(XXXConfiguration.class) 来实现装配。 所以我们进入到 RetryConfiguration 中，先看这样一段代码 123456789101112131415161718@PostConstructpublic void init() { Set&lt;Class&lt;? extends Annotation&gt;&gt; retryableAnnotationTypes = new LinkedHashSet&lt;Class&lt;? extends Annotation&gt;&gt;(1); retryableAnnotationTypes.add(Retryable.class); this.pointcut = buildPointcut(retryableAnnotationTypes); this.advice = buildAdvice(); if (this.advice instanceof BeanFactoryAware) { ((BeanFactoryAware) this.advice).setBeanFactory(beanFactory); }}... protected Advice buildAdvice() { AnnotationAwareRetryOperationsInterceptor interceptor = new AnnotationAwareRetryOperationsInterceptor(); ... return interceptor;} @PostConstruct 用于在完成依赖注入以执行任何初始化之后需要执行的方法。所以上面这段代码我们理解为在 RetryConfiguration初始化后完成对 RetryConfiguration#advice 的初始化。 RetryConfiguration#advice 指向的是 AnnotationAwareRetryOperationsInterceptor ，是切面（或者代理）具体要执行的操作。 而在AnnotationAwareRetryOperationsInterceptor 中我们看到了一个熟悉的方法——invoke 12345678910@Overridepublic Object invoke(MethodInvocation invocation) throws Throwable { MethodInterceptor delegate = getDelegate(invocation.getThis(), invocation.getMethod()); if (delegate != null) { return delegate.invoke(invocation); } else { return invocation.proceed(); }} 当 delegate 不为空的时候执行 RetryOperationsInterceptor#invoke ，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public Object invoke(final MethodInvocation invocation) throws Throwable { String name; if (StringUtils.hasText(label)) { name = label; } else { name = invocation.getMethod().toGenericString(); } final String label = name; RetryCallback&lt;Object, Throwable&gt; retryCallback = new RetryCallback&lt;Object, Throwable&gt;() { public Object doWithRetry(RetryContext context) throws Exception { context.setAttribute(RetryContext.NAME, label); if (invocation instanceof ProxyMethodInvocation) { try { return ((ProxyMethodInvocation) invocation).invocableClone().proceed(); } catch (Exception e) { throw e; } catch (Error e) { throw e; } catch (Throwable e) { throw new IllegalStateException(e); } } else { throw new IllegalStateException(\"MethodInvocation of the wrong type detected - this should not happen with Spring AOP, so please raise an issue if you see this exception\"); } } }; if (recoverer != null) { ItemRecovererCallback recoveryCallback = new ItemRecovererCallback( invocation.getArguments(), recoverer); return this.retryOperations.execute(retryCallback, recoveryCallback); } return this.retryOperations.execute(retryCallback);} 上述代码创建了一个重试回调方法，然后执行重试操作（RetryTemplate#execute），而RetryTemplate#execute又调用了 RetryTemplate#doExecute 这是真正执行重试流程的地方， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586protected &lt;T, E extends Throwable&gt; T doExecute(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state) throws E, ExhaustedRetryException { RetryPolicy retryPolicy = this.retryPolicy; BackOffPolicy backOffPolicy = this.backOffPolicy; // 初始化重试策略上下文，如重试次数、上一次执行结果的异常信息等... RetryContext context = open(retryPolicy, state); if (this.logger.isTraceEnabled()) { this.logger.trace(\"RetryContext retrieved: \" + context); } // 利用ThreadLocal确保上下文能获取到RetryContext RetrySynchronizationManager.register(context); Throwable lastException = null; boolean exhausted = false; try { ... // 获取backoff上下文 BackOffContext backOffContext = ...; // 重试流程 while (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) { try { // 重置最后一次异常（确保本次执行结果不会受到上一次结果的影响） lastException = null; // 执行重试流程 return retryCallback.doWithRetry(context); } catch (Throwable e) { // 记录异常信息 lastException = e; try { registerThrowable(retryPolicy, state, context, e); } catch (Exception ex) { throw new TerminatedRetryException(\"Could not register throwable\", ex); } finally { // 执行异常拦截器 doOnErrorInterceptors(retryCallback, context, e); } if (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) { try { // 如果还有重试机会，则进行休眠、等待下一次重试 backOffPolicy.backOff(backOffContext); } catch (BackOffInterruptedException ex) { lastException = e; // 被其他线程阻止，则重试失败 throw ex; } } if (shouldRethrow(retryPolicy, context, state)) { // 确定重试失败，则抛出异常 throw RetryTemplate.&lt;E&gt;wrapIfNecessary(e); } } // 可以通过像circuit breaker 或者 rollback classifier 来退出重试 if (state != null &amp;&amp; context.hasAttribute(GLOBAL_STATE)) { break; } } ... exhausted = true; // 恢复回调，清理缓存等 return handleRetryExhausted(recoveryCallback, context, state); } catch (Throwable e) { throw RetryTemplate.&lt;E&gt;wrapIfNecessary(e); } finally { close(retryPolicy, context, state, lastException == null || exhausted); doCloseInterceptors(retryCallback, context, lastException); RetrySynchronizationManager.clear(); }} 总结上述简单的介绍了 Spring Retry 执行重试的操作的流程，原理也符合我们预先的猜测——动态代理。","link":"/2019/09/08/spring-retry-in-action/"},{"title":"Java8 Stream实战（一）","text":"参考自《Java 8实战》 什么是stream为什么使用Stream？因为它能让我们更高效地处理集合，让我们可以简洁地表达复杂的数据处理查询。此外，Stream可以透明地并行化。我们可以使用Stream API完成以下操作： 可以表达复杂的数据处理查询 可以使用filter、distinct、skip和limit对流做筛选和切片 可以使用map和flatmap提取或转换流中的元素 可以使用findFirst和findAny方法查找流中的元素 可以使用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词 可以使用reduce方法将流中的所有元素 迭代合并成一个结果 除此之外我们应该知道，流不仅可以 从集合创建，也可以从值、数组、文件以及iterate与generate等特定的方法创建。 stream实践准备工作创建交易员实体类： 1234567891011121314151617181920212223242526public class Trader { private String name; private String city; public Trader(String name, String city) { this.name = name; this.city = city; } public String getName() { return name; } public String getCity() { return city; } @Override public String toString() { return \"Trader{\" + \"name='\" + name + '\\'' + \", city='\" + city + '\\'' + '}'; }} 创建交易记录实体类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Transaction { private Trader trader; private int year; private int value; public Transaction(Trader trader, int year, int value) { this.trader = trader; this.year = year; this.value = value; } public Trader getTrader() { return trader; } public void setTrader(Trader trader) { this.trader = trader; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } @Override public String toString() { return \"Transaction{\" + \"trader=\" + trader + \", year=\" + year + \", value=\" + value + '}'; }} 这里我增加了一个工具类，用于获取测试demo所需的集合： 12345678910111213141516171819public class ListUtil { public static List&lt;Transaction&gt; getList() { Trader raoul = new Trader(\"Raoul\", \"Cambridge\"); Trader mario = new Trader(\"Mario\", \"Milan\"); Trader alan = new Trader(\"Alan\", \"Cambridge\"); Trader brian = new Trader(\"Brian\", \"Cambridge\"); return Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950) ); }} 编码1、找到2011年发生的所有交易，并按交易额排序（从低到高） 12345678910111213141516public class Demo01 { public static void main(String[] args) { List&lt;Transaction&gt; collect = ListUtil.getList() .stream() .filter(n -&gt; n.getYear() == 2011) .sorted(Comparator.comparing(Transaction::getValue)) /// 从高到低 //.sorted(Comparator.comparing(Transaction::getValue).reversed()) .collect(Collectors.toList()); collect.forEach(System.out::println); }} 2、交易员都在哪些不同的城市工作过 123456789101112131415public class Demo02 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(n -&gt; n.getTrader().getCity()) .distinct() /// 返回一个List //.collect(Collectors.toList()); .collect(Collectors.joining(\", \")); System.out.println(collect); }} 3、查找所有来自剑桥的交易员并按照姓名排序 123456789101112131415public class Demo03 { public static void main(String[] args) { List&lt;Trader&gt; cambridge = ListUtil.getList() .stream() .map(Transaction::getTrader) .filter(trader -&gt; \"Cambridge\".equals(trader.getCity())) .distinct() .sorted(Comparator.comparing(Trader::getName)) .collect(Collectors.toList()); cambridge.forEach(System.out::println); }} 4、返回所有交易员的姓名字符串，按照字母顺序排序 1234567891011121314public class Demo04 { public static void main(String[] args) { String collect = ListUtil.getList() .stream() .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .sorted(String::compareTo) .collect(Collectors.joining(\", \")); System.out.println(collect); }} 5、有没有交易员是在米兰工作的 12345678910111213141516171819public class Demo05 { public static void main(String[] args) { ListUtil.getList() .stream() .filter(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())) .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .forEach(System.out::println); // 参考 boolean b = ListUtil.getList() .stream() .anyMatch(transaction -&gt; \"Milan\".equals(transaction.getTrader().getCity())); System.out.println(b); }} 6、打印生活在剑桥的交易员的所有交易额 123456789101112131415161718192021public class Demo06 { public static void main(String[] args) { // 总交易额 int sum = ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .mapToInt(Transaction::getValue) .sum(); System.out.println(\"总交易额: \" + sum); // 参考 ListUtil.getList() .stream() .filter(transaction -&gt; \"Cambridge\".equals(transaction.getTrader().getCity())) .map(Transaction::getValue) .forEach(System.out::println); }} 7、所有的交易额中，最高的交易额是多少 12345678910111213141516171819202122232425262728public class Demo07 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue).reversed()) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 OptionalInt reduce = ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max); if (reduce.isPresent()) { System.out.println(reduce.getAsInt()); } // 参考 ListUtil.getList() .stream() .mapToInt(Transaction::getValue) .reduce(Integer::max) .ifPresent(System.out::println); }} 8、找到交易额中最小的交易额 12345678910111213141516171819public class Demo08 { public static void main(String[] args) { ListUtil.getList() .stream() .sorted(Comparator.comparing(Transaction::getValue)) .mapToInt(Transaction::getValue) .limit(1) .forEach(System.out::println); // 参考 ListUtil.getList() .stream() .map(Transaction::getValue) .reduce(Integer::min) .ifPresent(System.out::println); }} 至此，关于stream的8个demo介绍完毕，这只是简单的介绍用法，关于stream还有很多东西值得我们去探索，像stream的筛选和切片、映射、查找和匹配、规约、以及各类收集器（我们甚至可以自定义收集器）。后续我会陆续更新，敬请期待。。。","link":"/2018/08/13/stream-in-action-01/"}],"tags":[{"name":"Annotation","slug":"Annotation","link":"/tags/Annotation/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"YAML","slug":"YAML","link":"/tags/YAML/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"MapStruct","slug":"MapStruct","link":"/tags/MapStruct/"},{"name":"MinIO","slug":"MinIO","link":"/tags/MinIO/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","link":"/tags/Spring-Cloud-Gateway/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Spring Async","slug":"Spring-Async","link":"/tags/Spring-Async/"},{"name":"Spring Resty","slug":"Spring-Resty","link":"/tags/Spring-Resty/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"杂记","slug":"杂记","link":"/categories/杂记/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/categories/Spring-Cloud/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"}]}